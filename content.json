{"meta":{"title":"张白告的个人博客","subtitle":"","description":"","author":"Zhang hao","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2020-03-21T15:32:35.000Z","updated":"2020-03-22T09:41:48.412Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Nginx","date":"2020-03-22T09:23:13.000Z","updated":"2020-03-22T09:25:46.157Z","comments":true,"path":"Nginx/index.html","permalink":"http://yoursite.com/Nginx/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring框架学习-IOC/DI源码分析(三)","slug":"ring框架学习-IOC-DI源码分析-三","date":"2020-04-09T14:22:39.000Z","updated":"2020-04-09T14:51:32.776Z","comments":true,"path":"2020/04/09/ring框架学习-IOC-DI源码分析-三/","link":"","permalink":"http://yoursite.com/2020/04/09/ring%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0-IOC-DI%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%89/","excerpt":"","text":"1.概念简介 IOC(Inversion of Control)控制反转: 所谓控制反转,就是把原先我们代码里面需要实现的对象创建、依赖的代码,反转给容器来帮忙实现。那么必然的我们需要创建一个容器,同时需要一种描述来让容器知道需要创建的对象与对象的关系。这个描述最具体表现就是我们可配置的文件。 DI(DependencyInjection)依赖注入: 就是指对象是被动接受依赖类而不是自己主动去找,换句话说就是指对象不是从容器中查找它依赖的类,而是在容器实例化对象的时候主动将它依赖的类注入给它。 2.最基本的IOC容器接口-BeanFactory&nbsp;&nbsp;&nbsp;&nbsp;SpringBean的创建是典型的工厂模式,这一系列的Bean工厂,也即IOC容器为开发者管理对象间的依赖关系提供了很多便利和基础服务,在Spring中有许多的IOC容器的实现供用户选择和使用,其相互关系如下: &nbsp;&nbsp;&nbsp;&nbsp;BeanFactory是最顶层接口，定义了IOC容器的基本功能规范，并有三个子类ListableBeanFactory、HierarchicalBeanFactory和AutowireCapableBeanFactory。BeanFactory的最终默认实现是DefaultListableBeanFactory，他实现了所有的接口。由于复杂的使用场合，所以定义了这么多层次的接口，它主要是为了区分在Spring内部在操作过程中对象的传递和转化过程中,对对象的数据访问所做的限制。&nbsp;&nbsp;&nbsp;&nbsp;例如ListableBeanFactory接口表示这些Bean是可列表的,而HierarchicalBeanFactory表示的是这些Bean是有继承关系的,也就是每个Bean有可能有父Bean。AutowireCapableBeanFactory接口定义Bean的自动装配规则。这四个接口共同定义了Bean的集合、Bean之间的关系、以及Bean行为.其源码如下 123456789101112131415161718192021222324public interface BeanFactory &#123; //对 FactoryBean 的转义定义,因为如果使用 bean 的名字检索 FactoryBean 得到的对象是工厂生成的对象, //如果需要得到工厂本身,需要转义 String FACTORY_BEAN_PREFIX = \"&amp;\"; //根据 bean 的名字,获取在 IOC 容器中得到 bean 实例 Object getBean(String name) throws BeansException; //根据 bean 的名字和 Class 类型来得到 bean 实例,增加了类型安全验证机制。 &lt;T&gt; T getBean(String name, @Nullable Class&lt;T&gt; requiredType) throws BeansException; Object getBean(String name, Object... args) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException; //提供对 bean 的检索,看看是否在 IOC 容器有这个名字的 bean boolean containsBean(String name); //根据 bean 名字得到 bean 实例,并同时判断这个 bean 是不是单例 boolean isSingleton(String name) throws NoSuchBeanDefinitionException; boolean isPrototype(String name) throws NoSuchBeanDefinitionException; boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException; boolean isTypeMatch(String name, @Nullable Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefinitionException; //得到 bean 实例的 Class 类型 @Nullable Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException; //得到 bean 的别名,如果根据别名检索,那么其原名也会被检索出来 String[] getAliases(String name);&#125; &nbsp;&nbsp;&nbsp;&nbsp;通过源码我们会发现BeanFactory里只对IOC容器的基本行为作了定义,根本不关心你的Bean是如何定义怎样加载的。正如我们只关心工厂里得到什么的产品对象,至于工厂是怎么生产这些对象的,这个基本的接口不关心。 &nbsp;&nbsp;&nbsp;&nbsp;至于具体是如何生产对象的，我们需要看具体的 IOC 容器实现,比如XmlBeanFactory,ClasspathXmlApplicationContext 等。其中 XmlBeanFactory 就是针对最基本的 IOC 容器的实现,这个 IOC 容器可以读取 XML 文件定义的 BeanDefinition(XML 文件中对 bean 的描述) &nbsp;&nbsp;&nbsp;&nbsp;ApplicationContext 是 Spring 提供的一个高级的 IOC 容器,它除了能够提供 IOC 容器的基本功能外,还为用户提供了以下的附加服务。1.支持信息源,可以实现国际化。(实现 MessageSource 接口)2.访问资源。(实现 ResourcePatternResolver 接口)3.支持应用事件。(实现 ApplicationEventPublisher 接口) 3.Bean对象描述-BeanDefinition&nbsp;&nbsp;&nbsp;&nbsp;BeanDefinition是用来描述spring中的Bean对象，其继承体系如下： &nbsp;&nbsp;&nbsp;&nbsp;由于要保证足够的灵活性以及拓展性，因此Bean 的解析过程非常复杂。Bean的解析主要就是对Spring 配置文件的解析。这个解析过程主要通过下图中的类完成: 4.IOC容器初始化&nbsp;&nbsp;&nbsp;&nbsp;初始化包括Resource 定位、载入和注册这三个基本的过程，我们以 ApplicationContext 为例,ApplicationContext 系列容器也许是我们最熟悉的,因为 Web项 目 中 使 用 的XmlWebApplicationContext 就 属 于 这 个 继 承 体 系 , 还 有ClasspathXmlApplicationContext 等,其继承体系如下图所示: &nbsp;&nbsp;&nbsp;&nbsp;ApplicationContext 允许上下文嵌套,通过保持父上下文可以维持一个上下文体系。对于 Bean 的查找可以在这个上下文体系中发生,首先检查当前上下文,其次是父上下文,逐级向上,这样为不同的Spring 应用提供了一个共享的 Bean 定义环境。 4.1XmlBeanFactory容器创建流程&nbsp;&nbsp;&nbsp;&nbsp;XmlBeanFactory源码如下： 12345678910public class XmlBeanFactory extends DefaultListableBeanFactory &#123; private final XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader( this ); public XmlBeanFactory( Resource resource ) throws BeansException &#123; this(resource, null); &#125; public XmlBeanFactory( Resource resource, BeanFactory parentBeanFactory ) throws BeansException &#123; super(parentBeanFactory); this.reader.loadBeanDefinitions( resource ); &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;参照源码，自己演示一遍，理解定位、载入、注册的全过程 12345678910// 根据 Xml 配置文件创建 Resource 资源对象，该对象中包含了 BeanDefinition 的信息ClassPathResource resource = new ClassPathResource(\"application-context.xml\");// 创建 DefaultListableBeanFactoryDefaultListableBeanFactory factory = new DefaultListableBeanFactory();//创建 XmlBeanDefinitionReader 读取器，用于载入 BeanDefinition。// 之所以需要 BeanFactory 作为参数，是因为会将读取的信息回调配置给 factoryXmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);// XmlBeanDefinitionReader 执行载入 BeanDefinition 的方法，最后会完成 Bean 的载入和注册。// 完成后 Bean 就成功的放置到 IOC 容器当中，以后我们就可以从中取得 Bean 来使用reader.loadBeanDefinitions(resource); &nbsp;&nbsp;&nbsp;&nbsp;通过前面的源码，XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(this);其中 this 传的是 factory 对象。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}],"keywords":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}]},{"title":"Spring框架学习-模块介绍(二)","slug":"pring框架学习-模块介绍-二","date":"2020-04-09T13:21:36.000Z","updated":"2020-04-09T13:43:17.114Z","comments":true,"path":"2020/04/09/pring框架学习-模块介绍-二/","link":"","permalink":"http://yoursite.com/2020/04/09/pring%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D-%E4%BA%8C/","excerpt":"","text":"1.Spring Framework模块结构图 2.核心模块 spring-core: 依赖注入IOC与DI的最基本实现,基础 API 模块,如资源管理,泛型处理spring-beans: Bean工厂与Bean的装配,依赖查找,依赖注入 &nbsp;&nbsp;&nbsp;&nbsp;spring-beans 和 spring-core 模块是 Spring 框架的核心模块,包含了控制反转(Inversion of Control, IOC)和依赖注入(Dependency Injection, DI)。BeanFactory 接口是 Spring 框架中的核心接口,它是工厂模式的具体实现。&nbsp;&nbsp;&nbsp;&nbsp;BeanFactory 使用控制反转对应用程序的配置和依赖性规范与实际的应用程序代码进行了分离。但 BeanFactory 容器实例化后并不会自动实例化 Bean,只有当 Bean被使用时BeanFactory 容器才会对该 Bean 进行实例化与依赖关系的装配。 spring-context: 定义基础的Spring的Context上下文即IOC容器,以及事件驱动、注解驱动,模块驱动等 &nbsp;&nbsp;&nbsp;&nbsp;扩展了 BeanFactory,为她添加了 Bean 生命周期控制、框架事件体系以及资源加载透明化等功能。此外该模块还提供了许多企业级支持,如邮件访问、远程访问、任务调度等,ApplicationContext 是该模块的核心接口,她是 BeanFactory 的超类,与BeanFactory 不同,ApplicationContext 容器实例化后会自动对所有的单实例 Bean 进行实例化与依赖关系的装配,使之处于待用状态。 spring-context-support: 对Spring IOC容器的扩展支持spring-context-indexer: Spring的类管理组件和Classpath扫描spring-expression: 是统一表达式语言(EL)的扩展模块,可以查询、管理运行中的对象,同时也方便的可以调用对象方法、操作数组、集合等。它的语法类似于传统 EL,但提供了额外的功能,最出色的要数函数调用和简单字符串的模板函数。这种语言的特性是基于 Spring 产品的需求而设计,他可以非常方便地同 Spring IOC 进行交互。 3.切面编程 spring-aop: 面向切面编程的应用模块,整合Asm,CGLIb、JDKProxy以JVM的动态代理技术为基础,然后设计出了一系列的 AOP 横切实现,比如前置通知、返回通知、异常通知等,同时,Pointcut 接口来匹配切入点,可以使用现有的切入点来设计横切面,也可以扩展相关方法根据需求进行切入。spring-aspects: 集成AspectJ,AOP应用框架，为 Spring AOP 提供多种 AOP 实现方法。spring-instrument: 动态Class Loading模块,主要作用是在 JVM 启用时,生成一个代理类,程序员通过代理类在运行时修改类的字节,从而改变一个类的功能,实现 AOP 的功能。 4.数据访问与集成 spring-jdbc: Spring 提供的JDBC抽象框架的主要实现模块,用于简化Spring JDBC操作,主要是提供 JDBC 模板方式、关系数据库对象化方式、SimpleJdbc 方式、事务管理来简化 JDBC 编程,主要实现类是 JdbcTemplate、SimpleJdbcTemplate 以及 NamedParameterJdbcTemplate。spring-tx: Spring JDBC事务控制实现模块spring-orm: ORM 框架支持模块,主要集成 Hibernate, Java Persistence API (JPA) 和Java Data Objects (JDO) 用于资源管理、数据访问对象(DAO)的实现和事务策略。spring-oxm: (Object-to-XML-Mapping)将Java对象映射成XML数据,或者将XML数据映射成Java对象spring-jms: Java Messaging Service能够发送和接收信息 5.web组件 spring-web: 提供了最基础Web支持,主要建立于核心容器之上,通过Servlet或者Listeners来初始化IOC容器。spring-webmvc: 实现了Spring MVC(model-view-Controller)的Web应用。spring-websocket: 主要是与Web前端的全双工通讯的协议。spring-webflux: 一个新的非堵塞函数式 Reactive Web 框架,可以用来建立异步的,非阻塞,事件驱动的服务。 6.通信报文 spring-messaging: 从Spring4开始新加入的一个模块,主要职责是为Spring 框架集成一些基础的报文传送应用。 7.集成测试 spring-test: 主要为测试提供支持的。 8.日志适配 spring-jcl: 通过适配器设计模式实现的一个用来统一管理日志的框架，对外体统统一的接口，采用”适配器类”将日志的操作全部委托给具体的日志框架，提供了对多种日志框架的支持。 9.模块之间的依赖关系","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}],"keywords":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}]},{"title":"Spring框架学习-概述(一)","slug":"-Spring框架学习-概述-一","date":"2020-04-09T12:47:05.000Z","updated":"2020-04-09T13:43:47.302Z","comments":true,"path":"2020/04/09/-Spring框架学习-概述-一/","link":"","permalink":"http://yoursite.com/2020/04/09/-Spring%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0-%E6%A6%82%E8%BF%B0-%E4%B8%80/","excerpt":"","text":"1.什么是 Spring Framework? &nbsp;&nbsp;&nbsp;&nbsp;Spring 是为解决企业级应用开发的复杂性而设计,根本的使命:简化开发。主要通过一下几点：1.基于 POJO 的轻量级和最小侵入性编程;2.通过依赖注入和面向接口松耦合;3.基于切面和惯性进行声明式编程;4.通过切面和模板减少样板式代码;而他主要是通过:面向 Bean、依赖注入以及面向切面这三种方式来达成的。 2.面向 Bean 的编程 &nbsp;&nbsp;&nbsp;&nbsp;面向 Bean 的编程(Bean Oriented Programming, BOP)，Spring 提供了 IOC 容器通过配置文件或者注解的方式来管理对象之间的依赖关系。 3.IOC控制反转 &nbsp;&nbsp;&nbsp;&nbsp;控制反转是一种设计思想思想，其中最常见的实现方式叫做依赖注入(Dependency Injection,DI)，还有一种方式叫“依赖查找”(Dependency Lookup,DL)，在最早的 Spring中是包含有依赖注入方法和依赖查询的,但因为依赖查询使用频率过低,不久就被 Spring 移除了,所以在 Spring 中控制反转也被称作依赖注入,她的基本概念是:不创建对象,但是描述创建它们的方式。 &nbsp;&nbsp;&nbsp;&nbsp;在代码中不直接与对象和服务连接,但在配置文件中描述哪一个组件需要哪一项服务。容器 (在 Spring框架中是 IOC 容器)负责将这些联系在一起。在典型的 IOC 场景中,容器创建了所有对象,并设置必要的属性将它们连接在一起,决定什么时间调用方法。 4.DI依赖注入 &nbsp;&nbsp;&nbsp;&nbsp;Spring 设计的核心 org.springframework.beans 包(架构核心是 org.springframework.core包),它的设计目标是与 JavaBean 组件一起使用。这个包通常不是由用户直接使用,而是由服务器将其用作其他多数功能的底层中介。&nbsp;&nbsp;&nbsp;&nbsp;下一个最高级抽象是 BeanFactory 接口,它是工厂设计模式的实现,允许通过名称创建和检索对象。BeanFactory 也可以管理对象之间的关系。BeanFactory 支持两个对象模型。&nbsp;&nbsp;&nbsp;&nbsp;1.单例:模型提供了具有特定名称的对象的共享实例,可以在查询时对其进行检索。 Singleton 是默认的也是最常用的对象模型。对于无状态服务对象很理想。&nbsp;&nbsp;&nbsp;&nbsp;2.原型:模型确保每次检索都会创建单独的对象。在每个用户都需要自己的对象时,原型模型最适合。&nbsp;&nbsp;&nbsp;&nbsp;Bean 工厂的概念是 Spring 作为 IOC 容器的基础。IOC 则将处理事情的责任从应用程序代码转移到框架。 5.AOP编程理念 &nbsp;&nbsp;&nbsp;&nbsp;面向切面编程,即AOP,是一种编程思想,它允许程序员对横切关注点或横切典型的职责分界线的行为(例如日志和事务管理)进行模块化。&nbsp;&nbsp;&nbsp;&nbsp;AOP的核心构造是方面(切面),它将那些影响多个类的行为封装到可重用的模块中。AOP和IOC是补充性的技术,它们都运用模块化方式解决企业应用程序开发中的复杂问题。&nbsp;&nbsp;&nbsp;&nbsp;在典型的面向对象开发方式中,可能要将日志记录语句放在所有方法和Java类中才能实现日志功能。在AOP方式中,可以反过来将日志服务模块化,并以声明的方式将它们应用到需要日志的组件上。当然,优势就是Java类不需要知道日志服务的存在,也不需要考虑相关的代码。所以,用SpringAOP编写的应用程序代码是松散耦合的。&nbsp;&nbsp;&nbsp;&nbsp;AOP的功能完全集成到了Spring事务管理、日志和其他各种特性的上下文中。AOP编程的常用场景有:Authentication权限认证、Logging日志、TransctionsManager事务、LazyLoading懒加载、ContextProcess上下文处理、ErrorHandler错误跟踪(异常捕获机制)、Cache缓存。 彩蛋 IoC 发展简介:• 1983年，Richard E. Sweet 在《The Mesa Programming Environment》中提出“HollywoodPrinciple”（好莱坞原则）• 1988年，Ralph E. Johnson &amp; Brian Foote 在《Designing Reusable Classes》中提出“Inversion of control”（控制反转）• 1996年，Michael Mattsson 在《Object-Oriented Frameworks, A survey of methodologicalissues》中将“Inversion of control”命名为 “Hollywood principle”• 2004年，Martin Fowler 在《Inversion of Control Containers and the Dependency Injectionpattern》中提出了自己对 IoC 以及 DI 的理解• 2005年，Martin Fowler 在 《InversionOfControl》对 IoC 做出进一步的说明","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}],"keywords":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}]},{"title":"Docker openjdk:8-jre-alpine FontConfiguration报错","slug":"Docker-openjdk-8-jre-alpine-FontConfiguration报NullPointerException","date":"2020-03-25T13:10:38.000Z","updated":"2020-03-25T13:29:17.053Z","comments":true,"path":"2020/03/25/Docker-openjdk-8-jre-alpine-FontConfiguration报NullPointerException/","link":"","permalink":"http://yoursite.com/2020/03/25/Docker-openjdk-8-jre-alpine-FontConfiguration%E6%8A%A5NullPointerException/","excerpt":"","text":"1.异常触发情况 本地使用Java8 生成验证码图片传给前端，本地调试没任何问题，但是部署到测试该接口就会报如下错误，而本地与测试唯一不同的就是，测试时使用Docker并且基础镜像是openjdk:8-jre-alpine，最后通过查阅资料了解到是Alpine缺少字体相关的包导致的 git上也有相关的issue：https://github.com/docker-library/openjdk/issues/73123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121ERROR 1 --- [ XNIO-2 task-5] c.o.t.controller.ExceptionController : java.lang.NullPointerException at sun.awt.FontConfiguration.getVersion(FontConfiguration.java:1264) at sun.awt.FontConfiguration.readFontConfigFile(FontConfiguration.java:219) at sun.awt.FontConfiguration.init(FontConfiguration.java:107) at sun.awt.X11FontManager.createFontConfiguration(X11FontManager.java:774) at sun.font.SunFontManager$2.run(SunFontManager.java:431) at java.security.AccessController.doPrivileged(Native Method) at sun.font.SunFontManager.&lt;init&gt;(SunFontManager.java:376) at sun.awt.FcFontManager.&lt;init&gt;(FcFontManager.java:35) at sun.awt.X11FontManager.&lt;init&gt;(X11FontManager.java:57) at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) at java.lang.reflect.Constructor.newInstance(Constructor.java:423) at java.lang.Class.newInstance(Class.java:442) at sun.font.FontManagerFactory$1.run(FontManagerFactory.java:83) at java.security.AccessController.doPrivileged(Native Method) at sun.font.FontManagerFactory.getInstance(FontManagerFactory.java:74) at java.awt.Font.getFont2D(Font.java:491) at java.awt.Font.access$000(Font.java:224) at java.awt.Font$FontAccessImpl.getFont2D(Font.java:228) at sun.font.FontUtilities.getFont2D(FontUtilities.java:180) at sun.java2d.SunGraphics2D.checkFontInfo(SunGraphics2D.java:670) at sun.java2d.SunGraphics2D.getFontInfo(SunGraphics2D.java:831) at sun.java2d.pipe.GlyphListPipe.drawString(GlyphListPipe.java:50) at sun.java2d.SunGraphics2D.drawString(SunGraphics2D.java:2926) at com.oczhkj.train.util.ImgValidateCodeUtil.drawString(ImgValidateCodeUtil.java:92) at com.oczhkj.train.util.ImgValidateCodeUtil.getImgCodeBaseCode(ImgValidateCodeUtil.java:119) at com.oczhkj.train.service.impl.UserServiceImpl.getRandomCode(UserServiceImpl.java:112) at com.oczhkj.train.service.impl.UserServiceImpl$$FastClassBySpringCGLIB$$8b28c57b.invoke(&lt;generated&gt;) at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204) at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:684) at com.oczhkj.train.service.impl.UserServiceImpl$$EnhancerBySpringCGLIB$$76a80bc6.getRandomCode(&lt;generated&gt;) at com.oczhkj.train.controller.UserController.getCode(UserController.java:45) at com.oczhkj.train.controller.UserController$$FastClassBySpringCGLIB$$c8905613.invoke(&lt;generated&gt;) at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204) at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:746) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) at org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor.invoke(MethodBeforeAdviceInterceptor.java:56) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:185) at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:88) at com.oczhkj.train.aop.WebLogAspect.doAround(WebLogAspect.java:49) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:644) at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:633) at org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:70) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:185) at org.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor.invoke(AfterReturningAdviceInterceptor.java:55) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:185) at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:185) at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:688) at com.oczhkj.train.controller.UserController$$EnhancerBySpringCGLIB$$d355a0b7.getCode(&lt;generated&gt;) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:209) at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:136) at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:102) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:877) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:783) at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:991) at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:925) at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:974) at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:866) at javax.servlet.http.HttpServlet.service(HttpServlet.java:687) at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:851) at javax.servlet.http.HttpServlet.service(HttpServlet.java:790) at io.undertow.servlet.handlers.ServletHandler.handleRequest(ServletHandler.java:74) at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:129) at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61) at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131) at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61) at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131) at org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:109) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61) at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131) at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:93) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61) at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131) at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:200) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61) at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131) at io.undertow.servlet.handlers.FilterHandler.handleRequest(FilterHandler.java:84) at io.undertow.servlet.handlers.security.ServletSecurityRoleHandler.handleRequest(ServletSecurityRoleHandler.java:62) at io.undertow.servlet.handlers.ServletChain$1.handleRequest(ServletChain.java:64) at io.undertow.servlet.handlers.ServletDispatchingHandler.handleRequest(ServletDispatchingHandler.java:36) at io.undertow.servlet.handlers.security.SSLInformationAssociationHandler.handleRequest(SSLInformationAssociationHandler.java:132) at io.undertow.servlet.handlers.security.ServletAuthenticationCallHandler.handleRequest(ServletAuthenticationCallHandler.java:57) at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43) at io.undertow.security.handlers.AbstractConfidentialityHandler.handleRequest(AbstractConfidentialityHandler.java:46) at io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler.handleRequest(ServletConfidentialityConstraintHandler.java:64) at io.undertow.security.handlers.AuthenticationMechanismsHandler.handleRequest(AuthenticationMechanismsHandler.java:60) at io.undertow.servlet.handlers.security.CachedAuthenticatedSessionHandler.handleRequest(CachedAuthenticatedSessionHandler.java:77) at io.undertow.security.handlers.AbstractSecurityContextAssociationHandler.handleRequest(AbstractSecurityContextAssociationHandler.java:43) at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43) at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43) at io.undertow.servlet.handlers.ServletInitialHandler.handleFirstRequest(ServletInitialHandler.java:292) at io.undertow.servlet.handlers.ServletInitialHandler.access$100(ServletInitialHandler.java:81) at io.undertow.servlet.handlers.ServletInitialHandler$2.call(ServletInitialHandler.java:138) at io.undertow.servlet.handlers.ServletInitialHandler$2.call(ServletInitialHandler.java:135) at io.undertow.servlet.core.ServletRequestContextThreadSetupAction$1.call(ServletRequestContextThreadSetupAction.java:48) at io.undertow.servlet.core.ContextClassLoaderSetupAction$1.call(ContextClassLoaderSetupAction.java:43) at io.undertow.servlet.handlers.ServletInitialHandler.dispatchRequest(ServletInitialHandler.java:272) at io.undertow.servlet.handlers.ServletInitialHandler.access$000(ServletInitialHandler.java:81) at io.undertow.servlet.handlers.ServletInitialHandler$1.handleRequest(ServletInitialHandler.java:104) at io.undertow.server.Connectors.executeRootHandler(Connectors.java:336) at io.undertow.server.HttpServerExchange$1.run(HttpServerExchange.java:830) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) 2.解决方案 在基础镜像里面安装ttf-dejavu，然后就可以了 1234567FROM java:8-jre-alpine# Install cURLRUN echo -e &quot;https:&#x2F;&#x2F;mirror.tuna.tsinghua.edu.cn&#x2F;alpine&#x2F;v3.4&#x2F;main\\n\\https:&#x2F;&#x2F;mirror.tuna.tsinghua.edu.cn&#x2F;alpine&#x2F;v3.4&#x2F;community&quot; &gt; &#x2F;etc&#x2F;apk&#x2F;repositoriesRUN apk --update add curl bash ttf-dejavu &amp;&amp; \\ rm -rf &#x2F;var&#x2F;cache&#x2F;apk&#x2F;* 1docker build -t docker.io&#x2F;java-font:8-jre-alpine . 最后构建我们自己项目的时候以此镜像为基础镜像即可","categories":[{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/tags/Docker/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}],"keywords":[{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/categories/Docker/"}]},{"title":"Docker部署Prometheus+grafana","slug":"Docker部署Prometheus-grafana","date":"2020-03-23T13:22:34.000Z","updated":"2020-03-24T03:57:21.046Z","comments":true,"path":"2020/03/23/Docker部署Prometheus-grafana/","link":"","permalink":"http://yoursite.com/2020/03/23/Docker%E9%83%A8%E7%BD%B2Prometheus-grafana/","excerpt":"","text":"1.新增prometheus.yml配置文件 job可以通过file_sd_configs方式挂载，也可以通过static_configs配置 12345678910111213141516171819202122global: scrape_interval: 15s scrape_timeout: 10s evaluation_interval: 1m external_labels: monitor: codelab-monitorscrape_configs:- job_name: prometheus honor_timestamps: true scrape_interval: 5s scrape_timeout: 5s metrics_path: &#x2F;metrics scheme: http static_configs: - targets: [&#39;192.168.237.6:9090&#39;]- job_name: &#39;node&#39; file_sd_configs: - files: [&#39;&#x2F;etc&#x2F;prometheus&#x2F;sd_config&#x2F;node.yml&#39;] refresh_interval: 5s- job_name: &#39;docker&#39; static_configs: - targets: [&#39;192.168.237.6:8080&#39;] file_sd_configs配置文件的格式 12targets: - 192.168.237.6:9100 2.exporter插件 cAdvisor：用于收集正在运行的容器资源使用和性能信息。 git地址：https://github.com/google/cadvisor 12345678910111213#!&#x2F;usr&#x2F;bin&#x2F;bashdocker stop cadvisordocker rm cadvisordocker run \\ --volume&#x3D;&#x2F;:&#x2F;rootfs:ro \\ --volume&#x3D;&#x2F;var&#x2F;run:&#x2F;var&#x2F;run:ro \\ --volume&#x3D;&#x2F;sys:&#x2F;sys:ro \\ --volume&#x3D;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;:&#x2F;var&#x2F;lib&#x2F;docker:ro \\ --volume&#x3D;&#x2F;dev&#x2F;disk&#x2F;:&#x2F;dev&#x2F;disk:ro \\ --publish&#x3D;8080:8080 \\ --detach&#x3D;true \\ --name&#x3D;cadvisor \\ google&#x2F;cadvisor node_exporter：用于Linux系统监控，使用Go语言编写的收集器。 官方文档：https://prometheus.io/docs/guides/node-exporter/ 1234567#!&#x2F;usr&#x2F;bin&#x2F;bashdocker stop node-exporterdocker rm node-exporterdocker run -d --name node-exporter -p 9100:9100 -v &quot;&#x2F;proc:&#x2F;host&#x2F;proc:ro&quot; -v &quot;&#x2F;sys:&#x2F;host&#x2F;sys:ro&quot; -v &quot;&#x2F;:&#x2F;rootfs:ro&quot; --restart&#x3D;always --net&#x3D;&quot;host&quot; prom&#x2F;node-exporter \\--path.procfs &#x2F;host&#x2F;proc \\--path.sysfs &#x2F;host&#x2F;sys \\--collector.filesystem.ignored-mount-points &quot;^&#x2F;(sys|proc|dev|host|etc)($|&#x2F;)&quot; 其他exporter:https://prometheus.io/docs/instrumenting/exporters/ 官方支持：https://prometheus.io/download/ 根据自己需求自行选择 3.Docker prometheus脚本 官方地址：https://prometheus.io/docs/prometheus/latest/installation/1234#!&#x2F;usr&#x2F;bin&#x2F;bashdocker stop prometheusdocker rm prometheusdocker run -d -p 9090:9090 --name prometheus -v &#x2F;volume&#x2F;prometheus&#x2F;prometheus.yml:&#x2F;etc&#x2F;prometheus&#x2F;prometheus.yml -v &#x2F;volume&#x2F;prometheus&#x2F;sd_config:&#x2F;etc&#x2F;prometheus&#x2F;sd_config prom&#x2F;prometheus 4.踩坑说明 若运行成功访问prometheus提示： Warning! Detected 545380.02 seconds time difference between your browser and the server. Prometheus relies on accurate time and time drift might cause unexpected query results. 则表示linux时间和本地机器时间不一致，更新linux时间即可123456789yum install -y ntpdatentpdate 0.asia.pool.ntp.org其他可选地址:ime.nist.govtime.nuri.net0.asia.pool.ntp.org1.asia.pool.ntp.org2.asia.pool.ntp.org3.asia.pool.ntp.org 5.效果 运行成功则会看到我们监控的节点 6.运行Grafana 官方地址：https://grafana.com/grafana/download?platform=docker 访问默认账户密码admin/admin，首次访问会要求修改密码1docker run -d --name&#x3D;grafana -p 3000:3000 grafana&#x2F;grafana 7.添加Prometheus 数据源 * 选择Prometheus，填写正确的服务地址 8.添加监控页面 Grafana提供了许多别人开发好的可视化界面，我们可以直接拿来使用 地址：https://grafana.com/grafana/dashboards 如监控linux我使用的是9276，cAdvisor使用的是193，这个数字是主题的id，在导入界面直接输入对应的id即可 9.最终界面展示 至此我们的Prometheus+grafana监控就完成了，运行效果如下，当然Prometheus还支持Alertmanager告警，以及k8s监控，后面会继续整理","categories":[{"name":"Prometheus","slug":"Prometheus","permalink":"http://yoursite.com/categories/Prometheus/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/tags/Docker/"},{"name":"Prometheus","slug":"Prometheus","permalink":"http://yoursite.com/tags/Prometheus/"},{"name":"Grafana","slug":"Grafana","permalink":"http://yoursite.com/tags/Grafana/"}],"keywords":[{"name":"Prometheus","slug":"Prometheus","permalink":"http://yoursite.com/categories/Prometheus/"}]},{"title":"Mysql 多表联合更新、select into、select update","slug":"Mysql-多表联、select into、select update合更新","date":"2020-03-23T12:58:19.000Z","updated":"2020-03-23T13:12:04.843Z","comments":true,"path":"2020/03/23/Mysql-多表联、select into、select update合更新/","link":"","permalink":"http://yoursite.com/2020/03/23/Mysql-%E5%A4%9A%E8%A1%A8%E8%81%94%E3%80%81select%20into%E3%80%81select%20update%E5%90%88%E6%9B%B4%E6%96%B0/","excerpt":"","text":"多表联合更新123UPDATE table1 a , table2 b SET a.x&#x3D;&#39;&#39;,b.x&#x3D;&#39;&#39; WHERE a.xx &#x3D; b.xxUPDATE table1 a JOIN table2 b ON a.x &#x3D; b.x SET a.xx&#x3D;&#39;&#39;,b.xx&#x3D;&#39;&#39;,a.xxx&#x3D;b.xxx select into1INSERT INTO table2 (column_name(s)) SELECT column_name(s) FROM table1; select update1update A inner join(select id,name from B) c on A.id &#x3D; c.id set A.name &#x3D; c.name;","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://yoursite.com/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://yoursite.com/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"http://yoursite.com/categories/Mysql/"}]},{"title":"Nginx 配置反向代理、负载均衡","slug":"Nginx-配置反向代理、负载均衡","date":"2020-03-22T14:15:01.000Z","updated":"2020-03-22T14:47:05.118Z","comments":true,"path":"2020/03/22/Nginx-配置反向代理、负载均衡/","link":"","permalink":"http://yoursite.com/2020/03/22/Nginx-%E9%85%8D%E7%BD%AE%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/","excerpt":"","text":"1.反向代理配置 在nginx.conf配置server块添加proxy_pass属性指定代理的地址 location / 支持正则匹配eg:location ~ /edu/ 匹配包含edu的请求123456789server &#123; listen 80; server_name localhost; location &#x2F; &#123; proxy_pass http:&#x2F;&#x2F;url:port; index index.html index.htm index.jsp; &#125; &#125; 参数说明： listen：该指令用于配置网络监听，有如下配置方式1234listen *:80 | *:8080 #监听所有80端口和8080端口listen IP_address:port #监听指定的地址和端口号listen IP_address #监听指定ip地址所有端口listen port #监听该端口的所有IP连接 server_name：用于配置基于名称的虚拟主机，有如下配置方式123server_name www.zhangbaigao.com 精确匹配,可以配置多个用空格隔开server_name *.zhangbaigao.com; *通配符匹配server_name ~^(?.+)\\.zhangbaigao\\.com$; 正则匹配. location：该指令用于URL匹配 12345678location [ &#x3D; | ~ | ~* | ^~] uri &#123;&#125;&#x3D; ：用于不含正则表达式的 uri 前，要求请求字符串与 uri 严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。~：用于表示 uri 包含正则表达式，并且区分大小写。~*：用于表示 uri 包含正则表达式，并且不区分大小写。^~：用于不含正则表达式的 uri 前，要求 Nginx 服务器找到标识 uri 和请求字符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location 块中的正则 uri 和请求字符串做匹配。注意：如果 uri 包含正则表达式，则必须要有 ~ 或者 ~* 标识。 proxy_pass:设置被代理服务器的地址 index:网站的默认首页,可以写多个用空格隔开 2.负载均衡配置 在nginx.conf配置中添加与server同级的upstream配置,同时配置location：1234567891011upstream zhangbgaigao &#123; ip_hash; server 127.0.0.1:8081 weight&#x3D;1; server 127.0.0.1:8082 weight&#x3D;1;&#125;server&#123; location &#x2F; &#123; proxy_pass http:&#x2F;&#x2F;zhangbgaigao; proxy_connect_timeout 10; &#125;&#125; 负载均衡策略 轮询(默认):请求按时间逐一分配到不同的服务器，如果服务器down机了，自动剔除 weight权重:默认为1，权重越高被分配的请求越多 ip_hash:每个请求按ip的hash结果分配，同一个ip固定分配到一个服务器，可以解决session问题 fair(第三方):按后端服务器的响应 时间来分配请求，响应时间短的优先分配","categories":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/tags/Nginx/"}],"keywords":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/categories/Nginx/"}]},{"title":"Hexo添加标签、分类、发布到git","slug":"Hexo添加标签、分类、发布到git","date":"2020-03-22T10:08:03.000Z","updated":"2020-03-22T10:31:20.176Z","comments":true,"path":"2020/03/22/Hexo添加标签、分类、发布到git/","link":"","permalink":"http://yoursite.com/2020/03/22/Hexo%E6%B7%BB%E5%8A%A0%E6%A0%87%E7%AD%BE%E3%80%81%E5%88%86%E7%B1%BB%E3%80%81%E5%8F%91%E5%B8%83%E5%88%B0git/","excerpt":"","text":"1.创建标签1$ hexo new page tags 编辑index添加type: tags 12345---title: 标签date: 2019-04-24 15:40:24type: tags--- 2.给文章添加标签 编辑文章添加内容 12345---title: Hexo 添加分类及标签date: 2019-04-24 15:40:24tags:[Nginx]--- 3.创建分类1$ hexo new page categories 编辑index添加type: “categories” 12345---title: 分类date: 2019-04-24 15:30:30type: categories--- 4.给文章添加分类12345---title: Hexo 添加分类及标签date: 2017-05-26 12:12:57categories: Hexo--- 5.Hexo Admin后台插件12npm install --save hexo-adminhexo server -d(开启hexo操作) 打开http://IP:4000/admin 就可以进入控制台 posts 新建博客 pages 页面 deploy 将更新的博客发布到github 6.提交到git 编辑根目录下_config.yml1234deploy: type: git repo: git@github.com:自己的名称&#x2F;自己的名称.github.io.git branch: master 12hexo g 这一步是生成静态页面hexo d 这个是部署到git上","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}],"keywords":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"}]},{"title":"Docker 部署 Nginx","slug":"Docker-部署-Nginx","date":"2020-03-22T08:08:20.000Z","updated":"2020-03-22T09:43:55.782Z","comments":true,"path":"2020/03/22/Docker-部署-Nginx/","link":"","permalink":"http://yoursite.com/2020/03/22/Docker-%E9%83%A8%E7%BD%B2-Nginx/","excerpt":"","text":"1.安装Nginx镜像1docker pull nginx 2.创建nginx.conf配置文件1234567891011121314151617181920212223242526272829303132333435363738394041worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application&#x2F;octet-stream; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 80; server_name localhost; # Vue路由模式为history需添加的配置 location &#x2F; &#123; if (!-e $request_filename) &#123; rewrite ^(.*)$ &#x2F;index.html?s&#x3D;$1 last; break; &#125; root &#x2F;home&#x2F;nginx&#x2F;www; index index.html; &#125; # 获取真实IP以及Websocket需添加的配置 proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; # 客户端Body大小限制（文件上传大小限制配置） client_max_body_size 5m; error_page 500 502 503 504 404 &#x2F;50x.html; location &#x3D; &#x2F;50x.html &#123; root html; &#125; &#125;&#125; 3.创建Nginx容器1234docker run -it -d --name nginx -p 81:80 \\-v &#x2F;home&#x2F;nginx&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf \\-v &#x2F;home&#x2F;nginx&#x2F;logs:&#x2F;var&#x2F;log&#x2F;nginx \\-v &#x2F;home&#x2F;nginx&#x2F;www:&#x2F;home&#x2F;nginx&#x2F;www nginx /home/nginx/conf/nginx.conf 为刚才创建配置文件的路径 /home/nginx/logs 日志保存的位置 /home/nginx/www 跳转静态资源位置 4.其他命令 docker ps | grep nginx 查看nginx容器运行状态 docker start mynginx 启动 docker start mynginx 重启 docker stop mynginx 暂停 docker rm mynginx 移除","categories":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/tags/Nginx/"},{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/tags/Docker/"}],"keywords":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/categories/Nginx/"}]},{"title":"Nginx 配置详解","slug":"Nginx-简介","date":"2020-03-22T07:40:54.000Z","updated":"2020-03-22T09:44:52.524Z","comments":true,"path":"2020/03/22/Nginx-简介/","link":"","permalink":"http://yoursite.com/2020/03/22/Nginx-%E7%AE%80%E4%BB%8B/","excerpt":"","text":"1.配置概览123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#user nobody;worker_processes 1;#error_log logs&#x2F;error.log;#error_log logs&#x2F;error.log notice;#error_log logs&#x2F;error.log info;#pid logs&#x2F;nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application&#x2F;octet-stream; #log_format main &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39; # &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39; # &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;; #access_log logs&#x2F;access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs&#x2F;host.access.log main; location &#x2F; &#123; root html; index index.html index.htm; &#125; #error_page 404 &#x2F;404.html; # redirect server error pages to the static page &#x2F;50x.html # error_page 500 502 503 504 &#x2F;50x.html; location &#x3D; &#x2F;50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http:&#x2F;&#x2F;127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME &#x2F;scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&#39;s document root # concurs with nginx&#39;s one # #location ~ &#x2F;\\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location &#x2F; &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location &#x2F; &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125; 2.全局快&ensp;&ensp;&ensp;&ensp;从配置文件开始到 events 块之间的内容，主要会设置一些影响 nginx 服务器整体运行的配置指令，主要包括配置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以及配置文件的引入等。 1worker_processes 1; &ensp;&ensp;&ensp;&ensp;这是 Nginx 服务器并发处理服务的关键配置,worker_processes 值越大，可以支持的并发处理量也越多，但是会受到硬件、软件等设备的制约。 3.events块123events &#123; worker_connections 1024;&#125; &ensp;&ensp;&ensp;&ensp;events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。&ensp;&ensp;&ensp;&ensp;上述例子就表示每个 work process 支持的最大连接数为 1024.&ensp;&ensp;&ensp;&ensp;这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。 4.http块12345678910111213http &#123; include mime.types; default_type application&#x2F;octet-stream; sendfile on; server &#123; listen 80; server_name localhost; location &#x2F; &#123; root html; index index.html index.htm; &#125; &#125;&#125; &ensp;&ensp;&ensp;&ensp;这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。&ensp;&ensp;&ensp;&ensp;需要注意的是：http 块也可以包括 http 全局块、server 块。 4.1 http全局快&ensp;&ensp;&ensp;&ensp;http 全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。 4.2 server块&ensp;&ensp;&ensp;&ensp;这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。 4.2.1全局server块&ensp;&ensp;&ensp;&ensp;最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或 IP 配置。 4.2.2 location块&ensp;&ensp;&ensp;&ensp;一个 server 块可以配置多个 location 块。&ensp;&ensp;&ensp;&ensp;这块的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称（也可以是 IP 别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。","categories":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/tags/Nginx/"}],"keywords":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/categories/Nginx/"}]}]}