{"meta":{"title":"张白告的个人博客","subtitle":"","description":"","author":"Zhang hao","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2020-03-21T15:32:35.000Z","updated":"2020-03-22T09:41:48.412Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"软件架构设计之－合成复用原则","slug":"件架构设计之－合成复用原则","date":"2020-04-11T04:18:11.000Z","updated":"2020-04-11T04:26:04.123Z","comments":true,"path":"2020/04/11/件架构设计之－合成复用原则/","link":"","permalink":"http://yoursite.com/2020/04/11/%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B9%8B%EF%BC%8D%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99/","excerpt":"","text":"1.简述 合成复用原则（Composite/Aggregate Reuse Principle,CARP）是指尽量使用对象组合(has-a)/聚合(contanis-a)，而不是继承关系达到软件复用的目的。可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少。 继承我们叫做白箱复用，相当于把所有的实现细节暴露给子类。组合/聚合也称之为黑箱复用，对类以外的对象是无法获取到实现细节的。要根据具体的业务场景来做代码设计，其实也都需要遵循 OOP 模型。 2.示例以数据库操作为例，先来创建 DBConnection 类： 12345public class DBConnection &#123; public String getConnection()&#123; return \"MySQL 数据库连接\"; &#125;&#125; 创建 ProductDao 类： 12345678910public class ProductDao&#123; private DBConnection dbConnection; public void setDbConnection(DBConnection dbConnection) &#123; this.dbConnection = dbConnection; &#125; public void addProduct()&#123; String conn = dbConnection.getConnection(); System.out.println(\"使用\"+conn+\"增加产品\"); &#125;&#125; 这就是一种非常典型的合成复用原则应用场景。但是，目前的设计来说，DBConnection还不是一种抽象，不便于系统扩展。目前的系统支持 MySQL 数据库连接，假设业务发生变化，数据库操作层要支持 Oracle 数据库。当然，我们可以在 DBConnection 中增加对Oracle 数据库支持的方法。但是违背了开闭原则。其实，我们可以不必修改 Dao 的代码，将 DBConnection 修改为 abstract，来看代码： 123public abstract class DBConnection &#123; public abstract String getConnection();&#125; 然后，将 MySQL 的逻辑抽离： 123456public class MySQLConnection extends DBConnection &#123; @Override public String getConnection() &#123; return \"MySQL 数据库连接\"; &#125;&#125; 再创建 Oracle 支持的逻辑： 123456public class OracleConnection extends DBConnection &#123; @Override public String getConnection() &#123; return \"Oracle 数据库连接\"; &#125;&#125; 具体选择交给应用层，来看一下类图：","categories":[{"name":"程序设计","slug":"程序设计","permalink":"http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"设计原则","slug":"设计原则","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}],"keywords":[{"name":"程序设计","slug":"程序设计","permalink":"http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"软件架构设计之－里氏替换原则","slug":"架构设计之－里氏替换原则","date":"2020-04-11T03:31:12.000Z","updated":"2020-04-11T04:25:54.103Z","comments":true,"path":"2020/04/11/架构设计之－里氏替换原则/","link":"","permalink":"http://yoursite.com/2020/04/11/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B9%8B%EF%BC%8D%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/","excerpt":"","text":"1.概述 在面向对象的程序设计中，里氏替换原则（Liskov Substitution principle）是对子类型的特别定义。它由芭芭拉·利斯科夫（Barbara Liskov）在1987年在一次会议上名为“数据的抽象与层次”的演说中首先提出。 里氏替换原则的内容可以描述为： “派生类（子类）对象可以在程序中代替其基类（超类）对象。” 以上内容并非利斯科夫的原文，而是译自罗伯特·马丁（Robert Martin）对原文的解读。其原文为： 芭芭拉·利斯科夫与周以真（Jeannette Wing）在1994年发表论文并提出以上的Liskov代换原则。 引申含义：子类可以扩展父类的功能，但不能改变父类原有的功能。 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。 子类中可以增加自己特有的方法。 当子类的方法重载父类的方法时，方法的前置条件（即方法的输入/入参）要比父类方法的输入参数更宽松。 当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的输出/返回值）要比父类更严格或相等。 2.示例在前面开闭原则时，我们重写覆盖了父类的getPrice()方法，增加了一个获取源码的方法getOriginPrice()，显然就违背了里氏替换原则。我们修改一下代码，不应该覆盖 getPrice()方法，增加 getDiscountPrice()方法： 12345678public class JavaDiscountCourse extends JavaCourse &#123; public JavaDiscountCourse(Integer id, String name, Double price) &#123; super(id, name, price); &#125; public Double getDiscountPrice()&#123; return super.getPrice() * 0.61; &#125;&#125; 使用里氏替换原则有以下优点： 约束继承泛滥，开闭原则的一种体现。 加强程序的健壮性，同时变更时也可以做到非常好的兼容性，提高程序的维护性、扩展性。降低需求变更时引入的风险。 现在来描述一个经典的业务场景，用正方形、矩形和四边形的关系说明里氏替换原则，我们都知道正方形是一个特殊的长方形，那么就可以创建一个长方形父类 Rectangle 类： 12345678910111213141516public class Rectangle &#123; private long height; private long width; public long getWidth() &#123; return width; &#125; public long getLength() &#123; return length; &#125; public void setLength(long length) &#123; this.length = length; &#125; public void setWidth(long width) &#123; this.width = width; &#125;&#125; 创建正方形 Square 类继承长方形： 12345678910111213141516171819202122232425public class Square extends Rectangle &#123; private long length; public long getLength() &#123; return length; &#125; public void setLength(long length) &#123; this.length = length; &#125; @Override public long getHeight() &#123; return getLength(); &#125; @Override public void setHeight(long height) &#123; setLength(height); &#125; @Override public long getWidth() &#123; return getLength(); &#125; @Override public void setWidth(long width) &#123; setLength(width); &#125;&#125; 在测试类中创建 resize()方法，根据逻辑长方形的宽应该大于等于高，我们让高一直自增，直到高等于宽变成正方形： 1234567public static void resize(Rectangle rectangle)&#123; while (rectangle.getWidth() &gt;= rectangle.getHeight())&#123; rectangle.setHeight(rectangle.getHeight() + 1); System.out.println(\"width:\"+rectangle.getWidth() + \",height:\"+rectangle.getHeight()); &#125; System.out.println(\"resize 方法结束width:\"+rectangle.getWidth() + \",height:\"+rectangle.getHeight());&#125; 测试代码： 123456public static void main(String[] args) &#123; Rectangle rectangle = new Rectangle(); rectangle.setWidth(20); rectangle.setHeight(10); resize(rectangle);&#125; 运行结果：发现高比宽还大了，在长方形中是一种非常正常的情况。现在我们再来看下面的代码，把长方形 Rectangle 替换成它的子类正方形 Square，修改测试代码： 12345public static void main(String[] args) &#123; Square square = new Square(); square.setLength(10); resize(square);&#125; 这时候我们运行的时候就出现了死循环，违背了里氏替换原则，将父类替换为子类后，程序运行结果没有达到预期。因此，我们的代码设计是存在一定风险的。里氏替换原则只存在父类与子类之间，约束继承泛滥。我们再来创建一个基于长方形与正方形共同的抽象四边形 Quadrangle 接口： 1234public interface Quadrangle &#123; long getWidth(); long getHeight();&#125; 修改长方形 Rectangle 类： 1234567891011121314151617public class Rectangle implements Quadrangle &#123; private long height; private long width; @Override public long getWidth() &#123; return width; &#125; public long getHeight() &#123; return height; &#125; public void setHeight(long height) &#123; this.height = height; &#125; public void setWidth(long width) &#123; this.width = width; &#125;&#125; 修改正方形类 Square 类： 1234567891011121314151617public class Square implements Quadrangle &#123; private long length; public long getLength() &#123; return length; &#125; public void setLength(long length) &#123; this.length = length; &#125; @Override public long getWidth() &#123; return length; &#125; @Override public long getHeight() &#123; return length; &#125;&#125; 此时，如果我们把 resize()方法的参数换成四边形 Quadrangle 类，方法内部就会报错。因为正方形 Square 已经没有了 setWidth()和 setHeight()方法了。因此，为了约束继承泛滥，resize()的方法参数只能用 Rectangle 长方形。","categories":[{"name":"程序设计","slug":"程序设计","permalink":"http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"设计原则","slug":"设计原则","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}],"keywords":[{"name":"程序设计","slug":"程序设计","permalink":"http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"软件架构设计之－迪米特法则","slug":"件架构设计之－迪米特法则","date":"2020-04-11T03:20:50.000Z","updated":"2020-04-11T03:29:53.841Z","comments":true,"path":"2020/04/11/件架构设计之－迪米特法则/","link":"","permalink":"http://yoursite.com/2020/04/11/%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B9%8B%EF%BC%8D%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/","excerpt":"","text":"1.概述 得墨忒耳定律（Law of Demeter，缩写LoD）亦被称作“最少知识原则（Principle of Least Knowledge）”，是一种软件开发的设计指导原则，特别是面向对象的程序设计。得墨忒耳定律是松耦合的一种具体案例。 该原则是美国东北大学在1987年末在发明的，可以简单地以下面任一种方式总结: 每个单元对于其他的单元只能拥有有限的知识：只是与当前单元紧密联系的单元； 每个单元只能和它的朋友交谈：不能和陌生单元交谈； 只和自己直接的朋友交谈。 这个原理的名称来源于希腊神话中的农业女神，孤独的得墨忒耳。很多面向对象程序设计语言用”.”表示对象的域的解析算符，因此得墨忒耳定律可以简单地陈述为“只使用一个.算符”。因此，a.b.Method()违反了此定律，而a.Method()不违反此定律。一个简单例子是，人可以命令一条狗行走（walk），但是不应该直接指挥狗的腿行走，应该由狗去指挥控制它的腿如何行走。 得墨忒耳定律使得软件更好的可维护性与适应性。因为对象较少依赖其它对象的内部结构，可以改变对象容器（container）而不用改变它的调用者（caller）。 2.示例现在来设计一个权限系统，Boss 需要查看目前发布到线上的课程数量。这时候，Boss要找到 TeamLeader 去进行统计，TeamLeader 再把统计结果告诉 Boss。接下来我们还是来看代码：Course 类： 12public class Course &#123;&#125; 123456TeamLeader 类：public class TeamLeader &#123; public void checkNumberOfCourses(List&lt;Course&gt; courseList)&#123; System.out.println(\"目前已发布的课程数量是：\"+courseList.size()); &#125;&#125; Boss 类： 12345678910public class Boss &#123; public void commandCheckNumber(TeamLeader teamLeader)&#123; //模拟 Boss 一页一页往下翻页，TeamLeader 实时统计 List&lt;Course&gt; courseList = new ArrayList&lt;Course&gt;(); for (int i= 0; i &lt; 20 ;i ++)&#123; courseList.add(new Course()); &#125; teamLeader.checkNumberOfCourses(courseList); &#125;&#125; 测试代码： 12345public static void main(String[] args) &#123; Boss boss = new Boss(); TeamLeader teamLeader = new TeamLeader(); boss.commandCheckNumber(teamLeader);&#125; 写到这里，其实功能已经都已经实现，代码看上去也没什么问题。根据迪米特原则，Boss只想要结果，不需要跟 Course 产生直接的交流。而 TeamLeader 统计需要引用 Course对象。Boss 和 Course 并不是朋友，从下面的类图就可以看出来：下面来对代码进行改造：TeamLeader 类： 123456789public class TeamLeader &#123; public void checkNumberOfCourses()&#123; List&lt;Course&gt; courseList = new ArrayList&lt;Course&gt;(); for(int i = 0 ;i &lt; 20;i++)&#123; courseList.add(new Course()); &#125; System.out.println(\"目前已发布的课程数量是：\"+courseList.size()); &#125;&#125; Boss 类： 12345public class Boss &#123; public void commandCheckNumber(TeamLeader teamLeader)&#123; teamLeader.checkNumberOfCourses();&#125;&#125; 再来看下面的类图，Course 和 Boss 已经没有关联了。","categories":[{"name":"程序设计","slug":"程序设计","permalink":"http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"设计原则","slug":"设计原则","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}],"keywords":[{"name":"程序设计","slug":"程序设计","permalink":"http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"软件架构设计之－接口隔离原则","slug":"架构设计之－接口隔离原则","date":"2020-04-10T13:49:24.000Z","updated":"2020-04-10T14:00:49.633Z","comments":true,"path":"2020/04/10/架构设计之－接口隔离原则/","link":"","permalink":"http://yoursite.com/2020/04/10/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B9%8B%EF%BC%8D%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/","excerpt":"","text":"1.概述 接口隔离原则（英语：interface-segregation principles， 缩写：ISP）指明客户（client）应该不依赖于它不使用的方法。接口隔离原则(ISP)拆分非常庞大臃肿的接口成为更小的和更具体的接口，这样客户将会只需要知道他们感兴趣的方法。这种缩小的接口也被称为角色接口（role interfaces）。接口隔离原则(ISP)的目的是系统解开耦合，从而容易重构，更改和重新部署。接口隔离原则是在SOLID (面向对象设计)中五个面向对象设计(OOD)的原则之一，类似于在GRASP (面向对象设计)中的高内聚性。 2.示例先定义一个动物行为的抽象IAnimal 接口： 12345public interface IAnimal &#123; void eat(); void fly(); void swim();&#125; Bird 类实现： 12345678public class Bird implements IAnimal &#123; @Override public void eat() &#123;&#125; @Override public void fly() &#123;&#125; @Override public void swim() &#123;&#125;&#125; Dog 类实现： 12345678public class Dog implements IAnimal &#123; @Override public void eat() &#123;&#125; @Override public void fly() &#123;&#125; @Override public void swim() &#123;&#125;&#125; 可以看出，Bird 的 swim()方法可能只能空着，Dog 的 fly()方法显然不可能的。这时候，我们针对不同动物行为来设计不同的接口，分别设计 IEatAnimal，IFlyAnimal 和ISwimAnimal 接口，来看代码： 123public interface IEatAnimal &#123; void eat();&#125; 123public interface IFlyAnimal &#123; void fly();&#125; 123public interface ISwimAnimal &#123; void swim();&#125; Dog 只实现 IEatAnimal 和 ISwimAnimal 接口： 123456public class Dog implements ISwimAnimal,IEatAnimal &#123; @Override public void eat() &#123;&#125; @Override public void swim() &#123;&#125;&#125; 来看下两种类图的对比，还是非常清晰明了的：","categories":[{"name":"程序设计","slug":"程序设计","permalink":"http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"设计原则","slug":"设计原则","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}],"keywords":[{"name":"程序设计","slug":"程序设计","permalink":"http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"软件架构设计之－单一功能原则","slug":"件架构设计之－单一职责原则","date":"2020-04-10T13:11:43.000Z","updated":"2020-04-10T13:41:45.814Z","comments":true,"path":"2020/04/10/件架构设计之－单一职责原则/","link":"","permalink":"http://yoursite.com/2020/04/10/%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B9%8B%EF%BC%8D%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/","excerpt":"","text":"1.简述 在面向对象编程领域中，单一功能原则（Single responsibility principle）规定每个类都应该有一个单一的功能，并且该功能应该由这个类完全封装起来。所有它的（这个类的）服务都应该严密的和该功能平行（功能平行，意味着没有依赖）。 这个术语由罗伯特·C·马丁（Robert Cecil Martin）在他的《敏捷软件开发，原则，模式和实践》一书中的一篇名为〈面向对象设计原则〉的文章中给出。马丁表述该原则是基于的《结构化分析和系统规格》一书中的内聚原则（Cohesion）上。 马丁把功能（职责）定义为：“改变的原因”，并且总结出一个类或者模块应该有且只有一个改变的原因。一个具体的例子就是，想象有一个用于编辑和打印报表的模块。这样的一个模块存在两个改变的原因。第一，报表的内容可以改变（编辑）。第二，报表的格式可以改变（打印）。这两方面会的改变因为完全不同的起因而发生：一个是本质的修改，一个是表面的修改。单一功能原则认为这两方面的问题事实上是两个分离的功能，因此他们应该分离在不同的类或者模块里。把有不同的改变原因的事物耦合在一起的设计是糟糕的。 保持一个类专注于单一功能点上的一个重要的原因是，它会使得类更加的健壮。继续上面的例子，如果有一个对于报表编辑流程的修改，那么将存在极大的危险性，因为假设这两个功能存在于同一个类中，修改报表的编辑流程会导致公共状态或者依赖关系的改变，打印功能的代码会因此不工作。 2.接口层单一功能示例先创建一个Course 类： 123456789public class Course &#123; public void study(String courseName)&#123; if(\"直播课\".equals(courseName))&#123; System.out.println(courseName + \"不能快进\"); &#125;else&#123; System.out.println(courseName + \"可以反复回看\"); &#125; &#125;&#125; 此时的调用代码为： 12345public static void main(String[] args) &#123; Course course = new Course(); course.study(\"直播课\"); course.study(\"录播课\");&#125; 从上面代码来看，Course 类承担了两种处理逻辑。假如，现在要对课程进行加密，那么直播课和录播课的加密逻辑都不一样，必须要修改代码。而修改代码逻辑势必会相互影响容易造成不可控的风险。 因此我们对职责进行分离解耦，分别创建两个类ReplayCourse 和 LiveCourse： 12345public class LiveCourse &#123; public void study(String courseName)&#123; System.out.println(courseName + \"不能快进看\"); &#125;&#125; 12345public class ReplayCourse &#123; public void study(String courseName)&#123; System.out.println(courseName + \"可以反复回\"); &#125;&#125; 此时的调用代码： 123456public static void main(String[] args) &#123; LiveCourse liveCourse = new LiveCourse(); liveCourse.study(\"直播课\"); ReplayCourse replayCourse = new ReplayCourse(); replayCourse.study(\"录播课\");&#125; 由于业务继续发展，课程要做权限。没有付费的学员可以获取课程基本信息，已经付费的学员可以获得视频流，即学习权限。那么对于控制课程层面上至少有两个职责。我们可以把展示职责和管理职责分离开来，都实现同一个抽象依赖。设计一个顶层接口,创建ICourse 接口： 12345678910public interface ICourse &#123; //获得基本信息 String getCourseName(); //获得视频流 byte[] getCourseVideo(); //学习课程 void studyCourse(); //退款 void refundCourse();&#125; 我们可以把这个接口拆成两个接口，创建一个接口 ICourseInfo 和 ICourseManager： 1234public interface ICourseInfo &#123; String getCourseName(); byte[] getCourseVideo();&#125; 1234public interface ICourseManager &#123; void studyCourse(); void refundCourse();&#125; 来看一下类图： 3.方法层面单一功能示例下面我们来看一下方法层面的单一职责设计。有时候，我们为了偷懒，通常会把一个方法写成下面这样： 1234private void modifyUserInfo(String userName,String address)&#123; userName = \"Tom\"; address = \"Changsha\";&#125; 或者这样： 12345678910111213private void modifyUserInfo(String userName,String... fileds)&#123; userName = \"Tom\"; // address = \"Changsha\"; &#125; private void modifyUserInfo(String userName,String address,boolean bool)&#123; if(bool)&#123; &#125;else&#123; &#125; userName = \"Tom\"; address = \"Changsha\";&#125; 显然，上面的 modifyUserInfo()方法中都承担了多个职责，既可以修改 userName,也可以修改 address，甚至更多，明显不符合单一职责。那么我们做如下修改，把这个方法拆成两个： 123456private void modifyUserName(String userName)&#123; userName = \"Tom\";&#125;private void modifyAddress(String address)&#123; address = \"Changsha\";&#125; 这修改之后，开发起来简单，维护起来也容易。但是，我们在实际开发中会项目依赖，组合，聚合这些关系，还有还有项目的规模，周期，技术人员的水平，对进度的把控，很多类都不符合单一职责。但是，我们在编写代码的过程，尽可能地让接口和方法保持单一职责，对我们项目后期的维护是有很大帮助的。","categories":[{"name":"程序设计","slug":"程序设计","permalink":"http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"设计原则","slug":"设计原则","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}],"keywords":[{"name":"程序设计","slug":"程序设计","permalink":"http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"软件架构设计之－依赖倒置原则","slug":"架构设计之－依赖倒置原则","date":"2020-04-10T13:02:37.000Z","updated":"2020-04-10T13:09:38.514Z","comments":true,"path":"2020/04/10/架构设计之－依赖倒置原则/","link":"","permalink":"http://yoursite.com/2020/04/10/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B9%8B%EF%BC%8D%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/","excerpt":"","text":"1.简述 依赖倒置原则(Dependence Inversion Principle,DIP)是指设计代码结构时,高层模块不应该依赖底层模块,二者都应该依赖其抽象。抽象不应该依赖细节;细节应该依赖抽象。通过依赖倒置,可以减少类与类之间的耦合性,提高系统的稳定性,提高代码的可读性和可维护性,并能够降低修改程序所造成的风险。 2.示例创建一个Tom类： 12345678public class Tom &#123; public void studyJavaCourse()&#123; System.out.println(\"Tomcat 在学习 Java 的课程\"); &#125; public void studyPythonCourse()&#123; System.out.println(\"Tomcat 在学习 Python 的课程\"); &#125;&#125; 如果此时业务拓展Tom需要学习AICourse课程,是不应在Tom类里面直接加入方法的，因为在Tom类中增加studyAICourse()的方法,在高层也要追加调用。如此一来,系统发布以后,实际上是非常不稳定的,在修改代码的同时也会带来意想不到的风险。首先创建课程抽象接口ICourse: 123public interface ICourse &#123; void study();&#125; 然后编写JavaCourse类实现ICourse接口： 123456public class JavaCourse implements ICourse &#123; @Override public void study() &#123; System.out.println(\"Tom 在学习 Java 课程\"); &#125;&#125; 再编写PythonCourse类同样实现ICourse接口： 123456public class PythonCourse implements ICourse &#123; @Override public void study() &#123; System.out.println(\"Tom 在学习 Python 课程\"); &#125;&#125; 修改 TomCat 类: 12345public class Tom &#123; public void study(ICourse course)&#123; course.study(); &#125;&#125; 调用： 12345public static void main(String[] args) &#123; Tom tom = new Tom(); tom.study(new JavaCourse()); tom.study(new PythonCourse());&#125; 此时如果需要再学习其他的课程，我只需要新建一个类,通过传参的方式告诉 Tom,而不需要修改底层代码。实际上这是一种大家非常熟悉的方式,叫依赖注入。注入的方式还有构造器方式和 setter方式。我们来看构造器注入方式: 123456789public class Tom &#123; private ICourse course; public Tom(ICourse course)&#123; this.course = course; &#125; public void study()&#123; course.study(); &#125;&#125; 调用代码: 1234public static void main(String[] args) &#123; Tom tom = new Tom(new JavaCourse()); tom.study();&#125; 根据构造器方式注入,在调用时,每次都要创建实例。那么,如果 Tom是全局单例,则我们就只能选择用 Setter 方式来注入,继续修改 Tom 类的代码: 123456789public class Tom &#123; private ICourse course; public void setCourse(ICourse course) &#123; this.course = course; &#125; public void study()&#123; course.study(); &#125;&#125; 调用代码： 1234567public static void main(String[] args) &#123; Tom tom = new Tom(); tom.setCourse(new JavaCourse()); tom.study(); tom.setCourse(new PythonCourse()); tom.study();&#125; 最终的类图： 以抽象为基准比以细节为基准搭建起来的架构要稳定得多，因此大家在拿到需求之后，要面向接口编程，先顶层再细节来设计代码结构。","categories":[{"name":"程序设计","slug":"程序设计","permalink":"http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"设计原则","slug":"设计原则","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}],"keywords":[{"name":"程序设计","slug":"程序设计","permalink":"http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"软件架构设计之－开闭原则","slug":"件架构设计之－开闭原则","date":"2020-04-10T13:01:46.000Z","updated":"2020-04-10T13:07:42.056Z","comments":true,"path":"2020/04/10/件架构设计之－开闭原则/","link":"","permalink":"http://yoursite.com/2020/04/10/%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B9%8B%EF%BC%8D%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/","excerpt":"","text":"１.简述 在面向对象编程领域中，开闭原则规定“软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的”，这意味着一个实体是允许在不改变它的源代码的前提下变更它的行为。该特性在产品化的环境中是特别有价值的，在这种环境中，改变源代码需要代码审查，单元测试以及诸如此类的用以确保产品使用质量的过程。遵循这种原则的代码在扩展时并不发生改变，因此无需上述的过程。 2.梅耶开闭原则 伯特兰·迈耶一般被认为是最早提出开闭原则这一术语的人，在他1988年发行的《面向对象软件构造》中给出。这一想法认为一旦完成，一个类的实现只应该因错误而修改，新的或者改变的特性应该通过新建不同的类实现。新建的类可以通过继承的方式来重用原类的代码。衍生的子类可以或不可以拥有和原类相同的接口。 梅耶的定义提倡实现继承。具体实现可以通过继承方式来重用，但是接口规格不必如此。已存在的实现对于修改是封闭的，但是新的实现不必实现原有的接口。 3.多态开闭原则 在20世纪90年代，开闭原则被广泛的重新定义由于抽象化接口的使用，在这中间实现可以被改变，多种实现可以被创建，并且多态化的替换不同的实现。 相比梅耶的使用方式，多态开闭原则的定义倡导对抽象基类的继承。接口规约可以通过继承来重用，但是实现不必重用。已存在的接口对于修改是封闭的，并且新的实现必须，至少，实现那个接口。 罗伯特·C·马丁1996年发表的文章《开闭原则》是使用这种方法的启发式著作。在2001年，Craig Larman把开闭原则关联到了Alistair Cockburn的名为受护的变量的模式以及David Parnas关于信息隐藏的讨论。 4.示例新建一个ICours课程接口： 12345public interface ICourse &#123; Integer getId(); String getName(); Double getPrice();&#125; 再创建一个JavaCourse具体的课程并实现ICours课程接口： 12345678910111213141516171819public class JavaCourse implements ICourse&#123; private Integer Id; private String name; private Double price; public JavaCourse(Integer id, String name, Double price) &#123; this.Id = id; this.name = name; this.price = price; &#125; public Integer getId() &#123; return this.Id; &#125; public String getName() &#123; return this.name; &#125; public Double getPrice() &#123; return this.price; &#125;&#125; 如果现在有新需求需要给JavaCourse课程做价格优惠活动,如果直接修改JavaCourse中的getPrice()方法,则会存在一定的风险,可能影响其他地方的调用结果。为了在不改变原有代码的前提下实现该活动，因此我们再定义一个优惠逻辑类JavaDiscountCourse： 1234567891011public class JavaDiscountCourse extends JavaCourse &#123; public JavaDiscountCourse(Integer id, String name, Double price) &#123; super(id, name, price); &#125; public Double getOriginPrice()&#123; return super.getPrice(); &#125; public Double getPrice()&#123; return super.getPrice() * 0.61; &#125;&#125; 由此就实现了在不改变原有结构基础上增加了活动功能，满足开闭原则对修改关闭,对拓展开放．","categories":[{"name":"程序设计","slug":"程序设计","permalink":"http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"设计原则","slug":"设计原则","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}],"keywords":[{"name":"程序设计","slug":"程序设计","permalink":"http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"Spring框架学习-IOC/DI源码分析(三)","slug":"ring框架学习-IOC-DI源码分析-三","date":"2020-04-09T14:22:39.000Z","updated":"2020-04-09T14:51:32.776Z","comments":true,"path":"2020/04/09/ring框架学习-IOC-DI源码分析-三/","link":"","permalink":"http://yoursite.com/2020/04/09/ring%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0-IOC-DI%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%89/","excerpt":"","text":"1.概念简介 IOC(Inversion of Control)控制反转: 所谓控制反转,就是把原先我们代码里面需要实现的对象创建、依赖的代码,反转给容器来帮忙实现。那么必然的我们需要创建一个容器,同时需要一种描述来让容器知道需要创建的对象与对象的关系。这个描述最具体表现就是我们可配置的文件。 DI(DependencyInjection)依赖注入: 就是指对象是被动接受依赖类而不是自己主动去找,换句话说就是指对象不是从容器中查找它依赖的类,而是在容器实例化对象的时候主动将它依赖的类注入给它。 2.最基本的IOC容器接口-BeanFactory&nbsp;&nbsp;&nbsp;&nbsp;SpringBean的创建是典型的工厂模式,这一系列的Bean工厂,也即IOC容器为开发者管理对象间的依赖关系提供了很多便利和基础服务,在Spring中有许多的IOC容器的实现供用户选择和使用,其相互关系如下: &nbsp;&nbsp;&nbsp;&nbsp;BeanFactory是最顶层接口，定义了IOC容器的基本功能规范，并有三个子类ListableBeanFactory、HierarchicalBeanFactory和AutowireCapableBeanFactory。BeanFactory的最终默认实现是DefaultListableBeanFactory，他实现了所有的接口。由于复杂的使用场合，所以定义了这么多层次的接口，它主要是为了区分在Spring内部在操作过程中对象的传递和转化过程中,对对象的数据访问所做的限制。&nbsp;&nbsp;&nbsp;&nbsp;例如ListableBeanFactory接口表示这些Bean是可列表的,而HierarchicalBeanFactory表示的是这些Bean是有继承关系的,也就是每个Bean有可能有父Bean。AutowireCapableBeanFactory接口定义Bean的自动装配规则。这四个接口共同定义了Bean的集合、Bean之间的关系、以及Bean行为.其源码如下 123456789101112131415161718192021222324public interface BeanFactory &#123; //对 FactoryBean 的转义定义,因为如果使用 bean 的名字检索 FactoryBean 得到的对象是工厂生成的对象, //如果需要得到工厂本身,需要转义 String FACTORY_BEAN_PREFIX = \"&amp;\"; //根据 bean 的名字,获取在 IOC 容器中得到 bean 实例 Object getBean(String name) throws BeansException; //根据 bean 的名字和 Class 类型来得到 bean 实例,增加了类型安全验证机制。 &lt;T&gt; T getBean(String name, @Nullable Class&lt;T&gt; requiredType) throws BeansException; Object getBean(String name, Object... args) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException; //提供对 bean 的检索,看看是否在 IOC 容器有这个名字的 bean boolean containsBean(String name); //根据 bean 名字得到 bean 实例,并同时判断这个 bean 是不是单例 boolean isSingleton(String name) throws NoSuchBeanDefinitionException; boolean isPrototype(String name) throws NoSuchBeanDefinitionException; boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException; boolean isTypeMatch(String name, @Nullable Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefinitionException; //得到 bean 实例的 Class 类型 @Nullable Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException; //得到 bean 的别名,如果根据别名检索,那么其原名也会被检索出来 String[] getAliases(String name);&#125; &nbsp;&nbsp;&nbsp;&nbsp;通过源码我们会发现BeanFactory里只对IOC容器的基本行为作了定义,根本不关心你的Bean是如何定义怎样加载的。正如我们只关心工厂里得到什么的产品对象,至于工厂是怎么生产这些对象的,这个基本的接口不关心。 &nbsp;&nbsp;&nbsp;&nbsp;至于具体是如何生产对象的，我们需要看具体的 IOC 容器实现,比如XmlBeanFactory,ClasspathXmlApplicationContext 等。其中 XmlBeanFactory 就是针对最基本的 IOC 容器的实现,这个 IOC 容器可以读取 XML 文件定义的 BeanDefinition(XML 文件中对 bean 的描述) &nbsp;&nbsp;&nbsp;&nbsp;ApplicationContext 是 Spring 提供的一个高级的 IOC 容器,它除了能够提供 IOC 容器的基本功能外,还为用户提供了以下的附加服务。1.支持信息源,可以实现国际化。(实现 MessageSource 接口)2.访问资源。(实现 ResourcePatternResolver 接口)3.支持应用事件。(实现 ApplicationEventPublisher 接口) 3.Bean对象描述-BeanDefinition&nbsp;&nbsp;&nbsp;&nbsp;BeanDefinition是用来描述spring中的Bean对象，其继承体系如下： &nbsp;&nbsp;&nbsp;&nbsp;由于要保证足够的灵活性以及拓展性，因此Bean 的解析过程非常复杂。Bean的解析主要就是对Spring 配置文件的解析。这个解析过程主要通过下图中的类完成: 4.IOC容器初始化&nbsp;&nbsp;&nbsp;&nbsp;初始化包括Resource 定位、载入和注册这三个基本的过程，我们以 ApplicationContext 为例,ApplicationContext 系列容器也许是我们最熟悉的,因为 Web项 目 中 使 用 的XmlWebApplicationContext 就 属 于 这 个 继 承 体 系 , 还 有ClasspathXmlApplicationContext 等,其继承体系如下图所示: &nbsp;&nbsp;&nbsp;&nbsp;ApplicationContext 允许上下文嵌套,通过保持父上下文可以维持一个上下文体系。对于 Bean 的查找可以在这个上下文体系中发生,首先检查当前上下文,其次是父上下文,逐级向上,这样为不同的Spring 应用提供了一个共享的 Bean 定义环境。 4.1XmlBeanFactory容器创建流程&nbsp;&nbsp;&nbsp;&nbsp;XmlBeanFactory源码如下： 12345678910public class XmlBeanFactory extends DefaultListableBeanFactory &#123; private final XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader( this ); public XmlBeanFactory( Resource resource ) throws BeansException &#123; this(resource, null); &#125; public XmlBeanFactory( Resource resource, BeanFactory parentBeanFactory ) throws BeansException &#123; super(parentBeanFactory); this.reader.loadBeanDefinitions( resource ); &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;参照源码，自己演示一遍，理解定位、载入、注册的全过程 12345678910// 根据 Xml 配置文件创建 Resource 资源对象，该对象中包含了 BeanDefinition 的信息ClassPathResource resource = new ClassPathResource(\"application-context.xml\");// 创建 DefaultListableBeanFactoryDefaultListableBeanFactory factory = new DefaultListableBeanFactory();//创建 XmlBeanDefinitionReader 读取器，用于载入 BeanDefinition。// 之所以需要 BeanFactory 作为参数，是因为会将读取的信息回调配置给 factoryXmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);// XmlBeanDefinitionReader 执行载入 BeanDefinition 的方法，最后会完成 Bean 的载入和注册。// 完成后 Bean 就成功的放置到 IOC 容器当中，以后我们就可以从中取得 Bean 来使用reader.loadBeanDefinitions(resource); &nbsp;&nbsp;&nbsp;&nbsp;通过前面的源码，XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(this);其中 this 传的是 factory 对象。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}],"keywords":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}]},{"title":"Spring框架学习-模块介绍(二)","slug":"pring框架学习-模块介绍-二","date":"2020-04-09T13:21:36.000Z","updated":"2020-04-09T13:43:17.114Z","comments":true,"path":"2020/04/09/pring框架学习-模块介绍-二/","link":"","permalink":"http://yoursite.com/2020/04/09/pring%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D-%E4%BA%8C/","excerpt":"","text":"1.Spring Framework模块结构图 2.核心模块 spring-core: 依赖注入IOC与DI的最基本实现,基础 API 模块,如资源管理,泛型处理spring-beans: Bean工厂与Bean的装配,依赖查找,依赖注入 &nbsp;&nbsp;&nbsp;&nbsp;spring-beans 和 spring-core 模块是 Spring 框架的核心模块,包含了控制反转(Inversion of Control, IOC)和依赖注入(Dependency Injection, DI)。BeanFactory 接口是 Spring 框架中的核心接口,它是工厂模式的具体实现。&nbsp;&nbsp;&nbsp;&nbsp;BeanFactory 使用控制反转对应用程序的配置和依赖性规范与实际的应用程序代码进行了分离。但 BeanFactory 容器实例化后并不会自动实例化 Bean,只有当 Bean被使用时BeanFactory 容器才会对该 Bean 进行实例化与依赖关系的装配。 spring-context: 定义基础的Spring的Context上下文即IOC容器,以及事件驱动、注解驱动,模块驱动等 &nbsp;&nbsp;&nbsp;&nbsp;扩展了 BeanFactory,为她添加了 Bean 生命周期控制、框架事件体系以及资源加载透明化等功能。此外该模块还提供了许多企业级支持,如邮件访问、远程访问、任务调度等,ApplicationContext 是该模块的核心接口,她是 BeanFactory 的超类,与BeanFactory 不同,ApplicationContext 容器实例化后会自动对所有的单实例 Bean 进行实例化与依赖关系的装配,使之处于待用状态。 spring-context-support: 对Spring IOC容器的扩展支持spring-context-indexer: Spring的类管理组件和Classpath扫描spring-expression: 是统一表达式语言(EL)的扩展模块,可以查询、管理运行中的对象,同时也方便的可以调用对象方法、操作数组、集合等。它的语法类似于传统 EL,但提供了额外的功能,最出色的要数函数调用和简单字符串的模板函数。这种语言的特性是基于 Spring 产品的需求而设计,他可以非常方便地同 Spring IOC 进行交互。 3.切面编程 spring-aop: 面向切面编程的应用模块,整合Asm,CGLIb、JDKProxy以JVM的动态代理技术为基础,然后设计出了一系列的 AOP 横切实现,比如前置通知、返回通知、异常通知等,同时,Pointcut 接口来匹配切入点,可以使用现有的切入点来设计横切面,也可以扩展相关方法根据需求进行切入。spring-aspects: 集成AspectJ,AOP应用框架，为 Spring AOP 提供多种 AOP 实现方法。spring-instrument: 动态Class Loading模块,主要作用是在 JVM 启用时,生成一个代理类,程序员通过代理类在运行时修改类的字节,从而改变一个类的功能,实现 AOP 的功能。 4.数据访问与集成 spring-jdbc: Spring 提供的JDBC抽象框架的主要实现模块,用于简化Spring JDBC操作,主要是提供 JDBC 模板方式、关系数据库对象化方式、SimpleJdbc 方式、事务管理来简化 JDBC 编程,主要实现类是 JdbcTemplate、SimpleJdbcTemplate 以及 NamedParameterJdbcTemplate。spring-tx: Spring JDBC事务控制实现模块spring-orm: ORM 框架支持模块,主要集成 Hibernate, Java Persistence API (JPA) 和Java Data Objects (JDO) 用于资源管理、数据访问对象(DAO)的实现和事务策略。spring-oxm: (Object-to-XML-Mapping)将Java对象映射成XML数据,或者将XML数据映射成Java对象spring-jms: Java Messaging Service能够发送和接收信息 5.web组件 spring-web: 提供了最基础Web支持,主要建立于核心容器之上,通过Servlet或者Listeners来初始化IOC容器。spring-webmvc: 实现了Spring MVC(model-view-Controller)的Web应用。spring-websocket: 主要是与Web前端的全双工通讯的协议。spring-webflux: 一个新的非堵塞函数式 Reactive Web 框架,可以用来建立异步的,非阻塞,事件驱动的服务。 6.通信报文 spring-messaging: 从Spring4开始新加入的一个模块,主要职责是为Spring 框架集成一些基础的报文传送应用。 7.集成测试 spring-test: 主要为测试提供支持的。 8.日志适配 spring-jcl: 通过适配器设计模式实现的一个用来统一管理日志的框架，对外体统统一的接口，采用”适配器类”将日志的操作全部委托给具体的日志框架，提供了对多种日志框架的支持。 9.模块之间的依赖关系","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}],"keywords":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}]},{"title":"Spring框架学习-概述(一)","slug":"-Spring框架学习-概述-一","date":"2020-04-09T12:47:05.000Z","updated":"2020-04-09T13:43:47.302Z","comments":true,"path":"2020/04/09/-Spring框架学习-概述-一/","link":"","permalink":"http://yoursite.com/2020/04/09/-Spring%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0-%E6%A6%82%E8%BF%B0-%E4%B8%80/","excerpt":"","text":"1.什么是 Spring Framework? &nbsp;&nbsp;&nbsp;&nbsp;Spring 是为解决企业级应用开发的复杂性而设计,根本的使命:简化开发。主要通过一下几点：1.基于 POJO 的轻量级和最小侵入性编程;2.通过依赖注入和面向接口松耦合;3.基于切面和惯性进行声明式编程;4.通过切面和模板减少样板式代码;而他主要是通过:面向 Bean、依赖注入以及面向切面这三种方式来达成的。 2.面向 Bean 的编程 &nbsp;&nbsp;&nbsp;&nbsp;面向 Bean 的编程(Bean Oriented Programming, BOP)，Spring 提供了 IOC 容器通过配置文件或者注解的方式来管理对象之间的依赖关系。 3.IOC控制反转 &nbsp;&nbsp;&nbsp;&nbsp;控制反转是一种设计思想思想，其中最常见的实现方式叫做依赖注入(Dependency Injection,DI)，还有一种方式叫“依赖查找”(Dependency Lookup,DL)，在最早的 Spring中是包含有依赖注入方法和依赖查询的,但因为依赖查询使用频率过低,不久就被 Spring 移除了,所以在 Spring 中控制反转也被称作依赖注入,她的基本概念是:不创建对象,但是描述创建它们的方式。 &nbsp;&nbsp;&nbsp;&nbsp;在代码中不直接与对象和服务连接,但在配置文件中描述哪一个组件需要哪一项服务。容器 (在 Spring框架中是 IOC 容器)负责将这些联系在一起。在典型的 IOC 场景中,容器创建了所有对象,并设置必要的属性将它们连接在一起,决定什么时间调用方法。 4.DI依赖注入 &nbsp;&nbsp;&nbsp;&nbsp;Spring 设计的核心 org.springframework.beans 包(架构核心是 org.springframework.core包),它的设计目标是与 JavaBean 组件一起使用。这个包通常不是由用户直接使用,而是由服务器将其用作其他多数功能的底层中介。&nbsp;&nbsp;&nbsp;&nbsp;下一个最高级抽象是 BeanFactory 接口,它是工厂设计模式的实现,允许通过名称创建和检索对象。BeanFactory 也可以管理对象之间的关系。BeanFactory 支持两个对象模型。&nbsp;&nbsp;&nbsp;&nbsp;1.单例:模型提供了具有特定名称的对象的共享实例,可以在查询时对其进行检索。 Singleton 是默认的也是最常用的对象模型。对于无状态服务对象很理想。&nbsp;&nbsp;&nbsp;&nbsp;2.原型:模型确保每次检索都会创建单独的对象。在每个用户都需要自己的对象时,原型模型最适合。&nbsp;&nbsp;&nbsp;&nbsp;Bean 工厂的概念是 Spring 作为 IOC 容器的基础。IOC 则将处理事情的责任从应用程序代码转移到框架。 5.AOP编程理念 &nbsp;&nbsp;&nbsp;&nbsp;面向切面编程,即AOP,是一种编程思想,它允许程序员对横切关注点或横切典型的职责分界线的行为(例如日志和事务管理)进行模块化。&nbsp;&nbsp;&nbsp;&nbsp;AOP的核心构造是方面(切面),它将那些影响多个类的行为封装到可重用的模块中。AOP和IOC是补充性的技术,它们都运用模块化方式解决企业应用程序开发中的复杂问题。&nbsp;&nbsp;&nbsp;&nbsp;在典型的面向对象开发方式中,可能要将日志记录语句放在所有方法和Java类中才能实现日志功能。在AOP方式中,可以反过来将日志服务模块化,并以声明的方式将它们应用到需要日志的组件上。当然,优势就是Java类不需要知道日志服务的存在,也不需要考虑相关的代码。所以,用SpringAOP编写的应用程序代码是松散耦合的。&nbsp;&nbsp;&nbsp;&nbsp;AOP的功能完全集成到了Spring事务管理、日志和其他各种特性的上下文中。AOP编程的常用场景有:Authentication权限认证、Logging日志、TransctionsManager事务、LazyLoading懒加载、ContextProcess上下文处理、ErrorHandler错误跟踪(异常捕获机制)、Cache缓存。 彩蛋 IoC 发展简介:• 1983年，Richard E. Sweet 在《The Mesa Programming Environment》中提出“HollywoodPrinciple”（好莱坞原则）• 1988年，Ralph E. Johnson &amp; Brian Foote 在《Designing Reusable Classes》中提出“Inversion of control”（控制反转）• 1996年，Michael Mattsson 在《Object-Oriented Frameworks, A survey of methodologicalissues》中将“Inversion of control”命名为 “Hollywood principle”• 2004年，Martin Fowler 在《Inversion of Control Containers and the Dependency Injectionpattern》中提出了自己对 IoC 以及 DI 的理解• 2005年，Martin Fowler 在 《InversionOfControl》对 IoC 做出进一步的说明","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}],"keywords":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}]},{"title":"Docker openjdk:8-jre-alpine FontConfiguration报错","slug":"Docker-openjdk-8-jre-alpine-FontConfiguration报NullPointerException","date":"2020-03-25T13:10:38.000Z","updated":"2020-03-25T13:29:17.053Z","comments":true,"path":"2020/03/25/Docker-openjdk-8-jre-alpine-FontConfiguration报NullPointerException/","link":"","permalink":"http://yoursite.com/2020/03/25/Docker-openjdk-8-jre-alpine-FontConfiguration%E6%8A%A5NullPointerException/","excerpt":"","text":"1.异常触发情况 本地使用Java8 生成验证码图片传给前端，本地调试没任何问题，但是部署到测试该接口就会报如下错误，而本地与测试唯一不同的就是，测试时使用Docker并且基础镜像是openjdk:8-jre-alpine，最后通过查阅资料了解到是Alpine缺少字体相关的包导致的 git上也有相关的issue：https://github.com/docker-library/openjdk/issues/73123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121ERROR 1 --- [ XNIO-2 task-5] c.o.t.controller.ExceptionController : java.lang.NullPointerException at sun.awt.FontConfiguration.getVersion(FontConfiguration.java:1264) at sun.awt.FontConfiguration.readFontConfigFile(FontConfiguration.java:219) at sun.awt.FontConfiguration.init(FontConfiguration.java:107) at sun.awt.X11FontManager.createFontConfiguration(X11FontManager.java:774) at sun.font.SunFontManager$2.run(SunFontManager.java:431) at java.security.AccessController.doPrivileged(Native Method) at sun.font.SunFontManager.&lt;init&gt;(SunFontManager.java:376) at sun.awt.FcFontManager.&lt;init&gt;(FcFontManager.java:35) at sun.awt.X11FontManager.&lt;init&gt;(X11FontManager.java:57) at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) at java.lang.reflect.Constructor.newInstance(Constructor.java:423) at java.lang.Class.newInstance(Class.java:442) at sun.font.FontManagerFactory$1.run(FontManagerFactory.java:83) at java.security.AccessController.doPrivileged(Native Method) at sun.font.FontManagerFactory.getInstance(FontManagerFactory.java:74) at java.awt.Font.getFont2D(Font.java:491) at java.awt.Font.access$000(Font.java:224) at java.awt.Font$FontAccessImpl.getFont2D(Font.java:228) at sun.font.FontUtilities.getFont2D(FontUtilities.java:180) at sun.java2d.SunGraphics2D.checkFontInfo(SunGraphics2D.java:670) at sun.java2d.SunGraphics2D.getFontInfo(SunGraphics2D.java:831) at sun.java2d.pipe.GlyphListPipe.drawString(GlyphListPipe.java:50) at sun.java2d.SunGraphics2D.drawString(SunGraphics2D.java:2926) at com.oczhkj.train.util.ImgValidateCodeUtil.drawString(ImgValidateCodeUtil.java:92) at com.oczhkj.train.util.ImgValidateCodeUtil.getImgCodeBaseCode(ImgValidateCodeUtil.java:119) at com.oczhkj.train.service.impl.UserServiceImpl.getRandomCode(UserServiceImpl.java:112) at com.oczhkj.train.service.impl.UserServiceImpl$$FastClassBySpringCGLIB$$8b28c57b.invoke(&lt;generated&gt;) at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204) at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:684) at com.oczhkj.train.service.impl.UserServiceImpl$$EnhancerBySpringCGLIB$$76a80bc6.getRandomCode(&lt;generated&gt;) at com.oczhkj.train.controller.UserController.getCode(UserController.java:45) at com.oczhkj.train.controller.UserController$$FastClassBySpringCGLIB$$c8905613.invoke(&lt;generated&gt;) at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204) at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:746) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) at org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor.invoke(MethodBeforeAdviceInterceptor.java:56) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:185) at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:88) at com.oczhkj.train.aop.WebLogAspect.doAround(WebLogAspect.java:49) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:644) at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:633) at org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:70) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:185) at org.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor.invoke(AfterReturningAdviceInterceptor.java:55) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:185) at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:185) at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:688) at com.oczhkj.train.controller.UserController$$EnhancerBySpringCGLIB$$d355a0b7.getCode(&lt;generated&gt;) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:209) at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:136) at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:102) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:877) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:783) at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:991) at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:925) at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:974) at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:866) at javax.servlet.http.HttpServlet.service(HttpServlet.java:687) at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:851) at javax.servlet.http.HttpServlet.service(HttpServlet.java:790) at io.undertow.servlet.handlers.ServletHandler.handleRequest(ServletHandler.java:74) at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:129) at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61) at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131) at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61) at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131) at org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:109) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61) at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131) at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:93) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61) at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131) at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:200) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61) at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131) at io.undertow.servlet.handlers.FilterHandler.handleRequest(FilterHandler.java:84) at io.undertow.servlet.handlers.security.ServletSecurityRoleHandler.handleRequest(ServletSecurityRoleHandler.java:62) at io.undertow.servlet.handlers.ServletChain$1.handleRequest(ServletChain.java:64) at io.undertow.servlet.handlers.ServletDispatchingHandler.handleRequest(ServletDispatchingHandler.java:36) at io.undertow.servlet.handlers.security.SSLInformationAssociationHandler.handleRequest(SSLInformationAssociationHandler.java:132) at io.undertow.servlet.handlers.security.ServletAuthenticationCallHandler.handleRequest(ServletAuthenticationCallHandler.java:57) at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43) at io.undertow.security.handlers.AbstractConfidentialityHandler.handleRequest(AbstractConfidentialityHandler.java:46) at io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler.handleRequest(ServletConfidentialityConstraintHandler.java:64) at io.undertow.security.handlers.AuthenticationMechanismsHandler.handleRequest(AuthenticationMechanismsHandler.java:60) at io.undertow.servlet.handlers.security.CachedAuthenticatedSessionHandler.handleRequest(CachedAuthenticatedSessionHandler.java:77) at io.undertow.security.handlers.AbstractSecurityContextAssociationHandler.handleRequest(AbstractSecurityContextAssociationHandler.java:43) at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43) at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43) at io.undertow.servlet.handlers.ServletInitialHandler.handleFirstRequest(ServletInitialHandler.java:292) at io.undertow.servlet.handlers.ServletInitialHandler.access$100(ServletInitialHandler.java:81) at io.undertow.servlet.handlers.ServletInitialHandler$2.call(ServletInitialHandler.java:138) at io.undertow.servlet.handlers.ServletInitialHandler$2.call(ServletInitialHandler.java:135) at io.undertow.servlet.core.ServletRequestContextThreadSetupAction$1.call(ServletRequestContextThreadSetupAction.java:48) at io.undertow.servlet.core.ContextClassLoaderSetupAction$1.call(ContextClassLoaderSetupAction.java:43) at io.undertow.servlet.handlers.ServletInitialHandler.dispatchRequest(ServletInitialHandler.java:272) at io.undertow.servlet.handlers.ServletInitialHandler.access$000(ServletInitialHandler.java:81) at io.undertow.servlet.handlers.ServletInitialHandler$1.handleRequest(ServletInitialHandler.java:104) at io.undertow.server.Connectors.executeRootHandler(Connectors.java:336) at io.undertow.server.HttpServerExchange$1.run(HttpServerExchange.java:830) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) 2.解决方案 在基础镜像里面安装ttf-dejavu，然后就可以了 1234567FROM java:8-jre-alpine# Install cURLRUN echo -e &quot;https:&#x2F;&#x2F;mirror.tuna.tsinghua.edu.cn&#x2F;alpine&#x2F;v3.4&#x2F;main\\n\\https:&#x2F;&#x2F;mirror.tuna.tsinghua.edu.cn&#x2F;alpine&#x2F;v3.4&#x2F;community&quot; &gt; &#x2F;etc&#x2F;apk&#x2F;repositoriesRUN apk --update add curl bash ttf-dejavu &amp;&amp; \\ rm -rf &#x2F;var&#x2F;cache&#x2F;apk&#x2F;* 1docker build -t docker.io&#x2F;java-font:8-jre-alpine . 最后构建我们自己项目的时候以此镜像为基础镜像即可","categories":[{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/tags/Docker/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}],"keywords":[{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/categories/Docker/"}]},{"title":"Docker部署Prometheus+grafana","slug":"Docker部署Prometheus-grafana","date":"2020-03-23T13:22:34.000Z","updated":"2020-03-24T03:57:21.046Z","comments":true,"path":"2020/03/23/Docker部署Prometheus-grafana/","link":"","permalink":"http://yoursite.com/2020/03/23/Docker%E9%83%A8%E7%BD%B2Prometheus-grafana/","excerpt":"","text":"1.新增prometheus.yml配置文件 job可以通过file_sd_configs方式挂载，也可以通过static_configs配置 12345678910111213141516171819202122global: scrape_interval: 15s scrape_timeout: 10s evaluation_interval: 1m external_labels: monitor: codelab-monitorscrape_configs:- job_name: prometheus honor_timestamps: true scrape_interval: 5s scrape_timeout: 5s metrics_path: &#x2F;metrics scheme: http static_configs: - targets: [&#39;192.168.237.6:9090&#39;]- job_name: &#39;node&#39; file_sd_configs: - files: [&#39;&#x2F;etc&#x2F;prometheus&#x2F;sd_config&#x2F;node.yml&#39;] refresh_interval: 5s- job_name: &#39;docker&#39; static_configs: - targets: [&#39;192.168.237.6:8080&#39;] file_sd_configs配置文件的格式 12targets: - 192.168.237.6:9100 2.exporter插件 cAdvisor：用于收集正在运行的容器资源使用和性能信息。 git地址：https://github.com/google/cadvisor 12345678910111213#!&#x2F;usr&#x2F;bin&#x2F;bashdocker stop cadvisordocker rm cadvisordocker run \\ --volume&#x3D;&#x2F;:&#x2F;rootfs:ro \\ --volume&#x3D;&#x2F;var&#x2F;run:&#x2F;var&#x2F;run:ro \\ --volume&#x3D;&#x2F;sys:&#x2F;sys:ro \\ --volume&#x3D;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;:&#x2F;var&#x2F;lib&#x2F;docker:ro \\ --volume&#x3D;&#x2F;dev&#x2F;disk&#x2F;:&#x2F;dev&#x2F;disk:ro \\ --publish&#x3D;8080:8080 \\ --detach&#x3D;true \\ --name&#x3D;cadvisor \\ google&#x2F;cadvisor node_exporter：用于Linux系统监控，使用Go语言编写的收集器。 官方文档：https://prometheus.io/docs/guides/node-exporter/ 1234567#!&#x2F;usr&#x2F;bin&#x2F;bashdocker stop node-exporterdocker rm node-exporterdocker run -d --name node-exporter -p 9100:9100 -v &quot;&#x2F;proc:&#x2F;host&#x2F;proc:ro&quot; -v &quot;&#x2F;sys:&#x2F;host&#x2F;sys:ro&quot; -v &quot;&#x2F;:&#x2F;rootfs:ro&quot; --restart&#x3D;always --net&#x3D;&quot;host&quot; prom&#x2F;node-exporter \\--path.procfs &#x2F;host&#x2F;proc \\--path.sysfs &#x2F;host&#x2F;sys \\--collector.filesystem.ignored-mount-points &quot;^&#x2F;(sys|proc|dev|host|etc)($|&#x2F;)&quot; 其他exporter:https://prometheus.io/docs/instrumenting/exporters/ 官方支持：https://prometheus.io/download/ 根据自己需求自行选择 3.Docker prometheus脚本 官方地址：https://prometheus.io/docs/prometheus/latest/installation/1234#!&#x2F;usr&#x2F;bin&#x2F;bashdocker stop prometheusdocker rm prometheusdocker run -d -p 9090:9090 --name prometheus -v &#x2F;volume&#x2F;prometheus&#x2F;prometheus.yml:&#x2F;etc&#x2F;prometheus&#x2F;prometheus.yml -v &#x2F;volume&#x2F;prometheus&#x2F;sd_config:&#x2F;etc&#x2F;prometheus&#x2F;sd_config prom&#x2F;prometheus 4.踩坑说明 若运行成功访问prometheus提示： Warning! Detected 545380.02 seconds time difference between your browser and the server. Prometheus relies on accurate time and time drift might cause unexpected query results. 则表示linux时间和本地机器时间不一致，更新linux时间即可123456789yum install -y ntpdatentpdate 0.asia.pool.ntp.org其他可选地址:ime.nist.govtime.nuri.net0.asia.pool.ntp.org1.asia.pool.ntp.org2.asia.pool.ntp.org3.asia.pool.ntp.org 5.效果 运行成功则会看到我们监控的节点 6.运行Grafana 官方地址：https://grafana.com/grafana/download?platform=docker 访问默认账户密码admin/admin，首次访问会要求修改密码1docker run -d --name&#x3D;grafana -p 3000:3000 grafana&#x2F;grafana 7.添加Prometheus 数据源 * 选择Prometheus，填写正确的服务地址 8.添加监控页面 Grafana提供了许多别人开发好的可视化界面，我们可以直接拿来使用 地址：https://grafana.com/grafana/dashboards 如监控linux我使用的是9276，cAdvisor使用的是193，这个数字是主题的id，在导入界面直接输入对应的id即可 9.最终界面展示 至此我们的Prometheus+grafana监控就完成了，运行效果如下，当然Prometheus还支持Alertmanager告警，以及k8s监控，后面会继续整理","categories":[{"name":"Prometheus","slug":"Prometheus","permalink":"http://yoursite.com/categories/Prometheus/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/tags/Docker/"},{"name":"Prometheus","slug":"Prometheus","permalink":"http://yoursite.com/tags/Prometheus/"},{"name":"Grafana","slug":"Grafana","permalink":"http://yoursite.com/tags/Grafana/"}],"keywords":[{"name":"Prometheus","slug":"Prometheus","permalink":"http://yoursite.com/categories/Prometheus/"}]},{"title":"Mysql 多表联合更新、select into、select update","slug":"Mysql-多表联、select into、select update合更新","date":"2020-03-23T12:58:19.000Z","updated":"2020-03-23T13:12:04.843Z","comments":true,"path":"2020/03/23/Mysql-多表联、select into、select update合更新/","link":"","permalink":"http://yoursite.com/2020/03/23/Mysql-%E5%A4%9A%E8%A1%A8%E8%81%94%E3%80%81select%20into%E3%80%81select%20update%E5%90%88%E6%9B%B4%E6%96%B0/","excerpt":"","text":"多表联合更新123UPDATE table1 a , table2 b SET a.x&#x3D;&#39;&#39;,b.x&#x3D;&#39;&#39; WHERE a.xx &#x3D; b.xxUPDATE table1 a JOIN table2 b ON a.x &#x3D; b.x SET a.xx&#x3D;&#39;&#39;,b.xx&#x3D;&#39;&#39;,a.xxx&#x3D;b.xxx select into1INSERT INTO table2 (column_name(s)) SELECT column_name(s) FROM table1; select update1update A inner join(select id,name from B) c on A.id &#x3D; c.id set A.name &#x3D; c.name;","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://yoursite.com/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://yoursite.com/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"http://yoursite.com/categories/Mysql/"}]},{"title":"Nginx 配置反向代理、负载均衡","slug":"Nginx-配置反向代理、负载均衡","date":"2020-03-22T14:15:01.000Z","updated":"2020-03-22T14:47:05.118Z","comments":true,"path":"2020/03/22/Nginx-配置反向代理、负载均衡/","link":"","permalink":"http://yoursite.com/2020/03/22/Nginx-%E9%85%8D%E7%BD%AE%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/","excerpt":"","text":"1.反向代理配置 在nginx.conf配置server块添加proxy_pass属性指定代理的地址 location / 支持正则匹配eg:location ~ /edu/ 匹配包含edu的请求123456789server &#123; listen 80; server_name localhost; location &#x2F; &#123; proxy_pass http:&#x2F;&#x2F;url:port; index index.html index.htm index.jsp; &#125; &#125; 参数说明： listen：该指令用于配置网络监听，有如下配置方式1234listen *:80 | *:8080 #监听所有80端口和8080端口listen IP_address:port #监听指定的地址和端口号listen IP_address #监听指定ip地址所有端口listen port #监听该端口的所有IP连接 server_name：用于配置基于名称的虚拟主机，有如下配置方式123server_name www.zhangbaigao.com 精确匹配,可以配置多个用空格隔开server_name *.zhangbaigao.com; *通配符匹配server_name ~^(?.+)\\.zhangbaigao\\.com$; 正则匹配. location：该指令用于URL匹配 12345678location [ &#x3D; | ~ | ~* | ^~] uri &#123;&#125;&#x3D; ：用于不含正则表达式的 uri 前，要求请求字符串与 uri 严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。~：用于表示 uri 包含正则表达式，并且区分大小写。~*：用于表示 uri 包含正则表达式，并且不区分大小写。^~：用于不含正则表达式的 uri 前，要求 Nginx 服务器找到标识 uri 和请求字符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location 块中的正则 uri 和请求字符串做匹配。注意：如果 uri 包含正则表达式，则必须要有 ~ 或者 ~* 标识。 proxy_pass:设置被代理服务器的地址 index:网站的默认首页,可以写多个用空格隔开 2.负载均衡配置 在nginx.conf配置中添加与server同级的upstream配置,同时配置location：1234567891011upstream zhangbgaigao &#123; ip_hash; server 127.0.0.1:8081 weight&#x3D;1; server 127.0.0.1:8082 weight&#x3D;1;&#125;server&#123; location &#x2F; &#123; proxy_pass http:&#x2F;&#x2F;zhangbgaigao; proxy_connect_timeout 10; &#125;&#125; 负载均衡策略 轮询(默认):请求按时间逐一分配到不同的服务器，如果服务器down机了，自动剔除 weight权重:默认为1，权重越高被分配的请求越多 ip_hash:每个请求按ip的hash结果分配，同一个ip固定分配到一个服务器，可以解决session问题 fair(第三方):按后端服务器的响应 时间来分配请求，响应时间短的优先分配","categories":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/tags/Nginx/"}],"keywords":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/categories/Nginx/"}]},{"title":"Hexo添加标签、分类、发布到git","slug":"Hexo添加标签、分类、发布到git","date":"2020-03-22T10:08:03.000Z","updated":"2020-03-22T10:31:20.176Z","comments":true,"path":"2020/03/22/Hexo添加标签、分类、发布到git/","link":"","permalink":"http://yoursite.com/2020/03/22/Hexo%E6%B7%BB%E5%8A%A0%E6%A0%87%E7%AD%BE%E3%80%81%E5%88%86%E7%B1%BB%E3%80%81%E5%8F%91%E5%B8%83%E5%88%B0git/","excerpt":"","text":"1.创建标签1$ hexo new page tags 编辑index添加type: tags 12345---title: 标签date: 2019-04-24 15:40:24type: tags--- 2.给文章添加标签 编辑文章添加内容 12345---title: Hexo 添加分类及标签date: 2019-04-24 15:40:24tags:[Nginx]--- 3.创建分类1$ hexo new page categories 编辑index添加type: “categories” 12345---title: 分类date: 2019-04-24 15:30:30type: categories--- 4.给文章添加分类12345---title: Hexo 添加分类及标签date: 2017-05-26 12:12:57categories: Hexo--- 5.Hexo Admin后台插件12npm install --save hexo-adminhexo server -d(开启hexo操作) 打开http://IP:4000/admin 就可以进入控制台 posts 新建博客 pages 页面 deploy 将更新的博客发布到github 6.提交到git 编辑根目录下_config.yml1234deploy: type: git repo: git@github.com:自己的名称&#x2F;自己的名称.github.io.git branch: master 12hexo g 这一步是生成静态页面hexo d 这个是部署到git上","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}],"keywords":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"}]},{"title":"Docker 部署 Nginx","slug":"Docker-部署-Nginx","date":"2020-03-22T08:08:20.000Z","updated":"2020-03-22T09:43:55.782Z","comments":true,"path":"2020/03/22/Docker-部署-Nginx/","link":"","permalink":"http://yoursite.com/2020/03/22/Docker-%E9%83%A8%E7%BD%B2-Nginx/","excerpt":"","text":"1.安装Nginx镜像1docker pull nginx 2.创建nginx.conf配置文件1234567891011121314151617181920212223242526272829303132333435363738394041worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application&#x2F;octet-stream; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 80; server_name localhost; # Vue路由模式为history需添加的配置 location &#x2F; &#123; if (!-e $request_filename) &#123; rewrite ^(.*)$ &#x2F;index.html?s&#x3D;$1 last; break; &#125; root &#x2F;home&#x2F;nginx&#x2F;www; index index.html; &#125; # 获取真实IP以及Websocket需添加的配置 proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; # 客户端Body大小限制（文件上传大小限制配置） client_max_body_size 5m; error_page 500 502 503 504 404 &#x2F;50x.html; location &#x3D; &#x2F;50x.html &#123; root html; &#125; &#125;&#125; 3.创建Nginx容器1234docker run -it -d --name nginx -p 81:80 \\-v &#x2F;home&#x2F;nginx&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf \\-v &#x2F;home&#x2F;nginx&#x2F;logs:&#x2F;var&#x2F;log&#x2F;nginx \\-v &#x2F;home&#x2F;nginx&#x2F;www:&#x2F;home&#x2F;nginx&#x2F;www nginx /home/nginx/conf/nginx.conf 为刚才创建配置文件的路径 /home/nginx/logs 日志保存的位置 /home/nginx/www 跳转静态资源位置 4.其他命令 docker ps | grep nginx 查看nginx容器运行状态 docker start mynginx 启动 docker start mynginx 重启 docker stop mynginx 暂停 docker rm mynginx 移除","categories":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/tags/Nginx/"},{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/tags/Docker/"}],"keywords":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/categories/Nginx/"}]},{"title":"Nginx 配置详解","slug":"Nginx-简介","date":"2020-03-22T07:40:54.000Z","updated":"2020-03-22T09:44:52.524Z","comments":true,"path":"2020/03/22/Nginx-简介/","link":"","permalink":"http://yoursite.com/2020/03/22/Nginx-%E7%AE%80%E4%BB%8B/","excerpt":"","text":"1.配置概览123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#user nobody;worker_processes 1;#error_log logs&#x2F;error.log;#error_log logs&#x2F;error.log notice;#error_log logs&#x2F;error.log info;#pid logs&#x2F;nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application&#x2F;octet-stream; #log_format main &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39; # &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39; # &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;; #access_log logs&#x2F;access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs&#x2F;host.access.log main; location &#x2F; &#123; root html; index index.html index.htm; &#125; #error_page 404 &#x2F;404.html; # redirect server error pages to the static page &#x2F;50x.html # error_page 500 502 503 504 &#x2F;50x.html; location &#x3D; &#x2F;50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http:&#x2F;&#x2F;127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME &#x2F;scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&#39;s document root # concurs with nginx&#39;s one # #location ~ &#x2F;\\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location &#x2F; &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location &#x2F; &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125; 2.全局快&ensp;&ensp;&ensp;&ensp;从配置文件开始到 events 块之间的内容，主要会设置一些影响 nginx 服务器整体运行的配置指令，主要包括配置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以及配置文件的引入等。 1worker_processes 1; &ensp;&ensp;&ensp;&ensp;这是 Nginx 服务器并发处理服务的关键配置,worker_processes 值越大，可以支持的并发处理量也越多，但是会受到硬件、软件等设备的制约。 3.events块123events &#123; worker_connections 1024;&#125; &ensp;&ensp;&ensp;&ensp;events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。&ensp;&ensp;&ensp;&ensp;上述例子就表示每个 work process 支持的最大连接数为 1024.&ensp;&ensp;&ensp;&ensp;这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。 4.http块12345678910111213http &#123; include mime.types; default_type application&#x2F;octet-stream; sendfile on; server &#123; listen 80; server_name localhost; location &#x2F; &#123; root html; index index.html index.htm; &#125; &#125;&#125; &ensp;&ensp;&ensp;&ensp;这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。&ensp;&ensp;&ensp;&ensp;需要注意的是：http 块也可以包括 http 全局块、server 块。 4.1 http全局快&ensp;&ensp;&ensp;&ensp;http 全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。 4.2 server块&ensp;&ensp;&ensp;&ensp;这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。 4.2.1全局server块&ensp;&ensp;&ensp;&ensp;最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或 IP 配置。 4.2.2 location块&ensp;&ensp;&ensp;&ensp;一个 server 块可以配置多个 location 块。&ensp;&ensp;&ensp;&ensp;这块的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称（也可以是 IP 别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。","categories":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/tags/Nginx/"}],"keywords":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/categories/Nginx/"}]}]}